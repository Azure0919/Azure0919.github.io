[{"title":"base-review-note","date":"2020-03-25T02:01:48.000Z","path":"/posts/6f4fed30/","text":"基础知识复习笔记 有错误的地方还请多多指教 （未完待续） 1. 运算符&amp;和&amp;&amp;,|和||的区别123&amp;:按位与操作 只有对应的2个二进制数都为1才为1&amp;和&amp;&amp;的区别&amp;俩边都运算,&amp;&amp;从左边开始运算,当左侧为false则右侧不运算 123|按位或,有一个为1则为1|和||的区别和上面类似,只要左侧满足条件后面就不再判断 1&amp;&amp;和||为短路运算符 2. 用最有效的方法计算2*8123456原理:将一个数左移n位,相当于*2的n次方,位运算是cpu直接支持的所以效率高2&lt;&lt;3常见的HashMap的默认容量16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16直接二进制操作,表示1左移4位,编程10000,转为10进制也就是16 3.写个方法,传递来个非0的int数值,实现变量交换的方式有几种?1234567891011121314方式一:public static void swap(int a,int b){ a = a+b; b = a-b; a = a-b; }方法二(异或运算,一个数与另一个数异或俩次是其本身,一个数和自身异或结果是0): public static void swap2(int a,int b){ System.out.println(\"a:\"+a+\",b:\"+b); a = a^b; b = b^a; a = a^b; System.out.println(\"a:\"+a+\",b:\"+b); } 4.try-catch-finally语句块,catch的return与finally的return返回值最终返回值的确定: 12345678在执行try,catch中的return之前一定会执行finally中的代码,(如果finally存在)如果finally中有return语句,就会执行执行finally中的return方法,所以finally中的return语句一定会被执行执行流程:finally执行前的代码有包含return,则会先确定return返回值,然后再执行finally的代码最后再执行return(如果finally代码块中 没有新的return那么就会返回原来确定好的return值) 5.说下java数据类型分类12341)基础数据类型 byte short int long float double char boolean2)引用数据类型其他都是引用类型(比如String和Enum) 6.运算12345678定义变量 int i =5return i++;return ++i;返回值分别为5,6i++先返回i再运算++I先运算再返回 7.== 和equals的区别123基本数据类型比较 用==判断引用数据类似: ==比较的是内存地址是否一样,不同对象的内存地址不一样,equals比较的是具体的内容,也可以让开发者去定义什么条件判断俩个对象是否一样 8.新版jdk处理io流:编写基础代码从一个txt文本里边拷贝文本到另外一个文本try-with-resources 123jdk7之后的写法,jdk9进行了改良,主要记住下面的写法,需要关闭的资源只要执行了java.io.Closeable,就可以自动被关闭,try()可以定义多个资源,他们的关闭顺序是后在try里边定义的最新关闭 123456789101112131415161718try { FileInputStream fis = new FileInputStream(\"D:/Readme.txt\"); BufferedInputStream bis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream(\"D:/Copy.txt\"); BufferedOutputStream bos = new BufferedOutputStream(fos); int size; byte[] buf = new byte[1024]; while ((size = bis.read(buf))!=-1){ bos.write(buf,0,size); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } 9.常见API和递归算法的考察:找出某目录下的所有子目录以及子文件并打印在控制台上 123456789101112131415161718192021222324public static void main(String[] args) { ArrayList&lt;String&gt; paths = new ArrayList&lt;String&gt;(); getAllFilePaths(new File(\"D:\\\\DeveloperTools\\\\Git\"),paths); for (String path : paths) { System.out.println(path); } } private static void getAllFilePaths(File filePaths, ArrayList&lt;String&gt; paths) { File[] files = filePaths.listFiles(); if (files==null){ return; }else{ for (File file : files) { if(file.isDirectory()){ paths.add(file.getPath()); getAllFilePaths(file,paths); }else { paths.add(file.getPath()); } } } } 10.常用字符串知识点1231)String str = new String(\"abc.net\")创建了几个对象?如果常量池存在,则直接在堆里new一个对象如果常量池不存在,则在常量池创建一个对象,也在堆里创建一个对象 12345678910112) 下面比较是比较什么?输出什么?为什么这样 String s1 = \"abc\"; String s2 = \"abc\"; String s3= new String(\"abc\"); System.out.println(\"s1 == s2 ? \"+(s1==s2)); //true System.out.println(\"s1 == s3 ? \"+(s1==s3)); //false System.out.println(\"s1 equals s3 ? \"+(s1.equals(s3))); //true有两种方式判断字符串是否相等，使用”==”或者使用equals方法。当使用”==”操作符不仅比较字符串的值，还会比较引用的内存地址。大多数情况下，我们只需要判断值是否相等，此时用equals方法比较即可。还有一个equalsIgnoreCase可以用来忽略大小写进行比较。 123456783)写出下面代码的结果?如果需要俩个都为true,应该怎么修改String s1 =\"abc\";String s2 =s1+\".net\"; //变量+常量 = 来自堆String s3 =\"abc\"+\".net\"; //常量+常量 =来自常量池 System.out.println(s2 == \"abc.net\"); //false System.out.println(\"s3 == \"abc.net\"); //true 修改: final String s1 =\"abc\";即可 将变量改成常量 11.String ,StringBuffer与StringBuilder的区别?使用场景1234567891011相同:三者都是final类 不允许被继承,底层都是cha[]数组实现String是不可变对象,其他俩个是可变的使用StringBuilder 效率快,不需要加锁不具备线程安全,不在多线程情况下使用StringBuffer 用synchronize加锁,效率低,线程安全场景:操作少量数用String单线程下用StringBuilder,虽然线程不安全但是效率高多线程情况下操作大量的字符串,且需要保证线程安全用StringBuffer 12.面向对象OOP思想,四大特性,分别解释1234抽象:abstract 声明的类和方法 共性又可变封装:private /protected /public 加强安全性继承:extend 具有公共的方法和属性 多态:同一行为具有不同的表现形式,减少耦合,灵活可配 13.接口篇1).Overload和Override区别?123456Overload:在同一个类可以有多个名称相同的方法,但是这些方法的参数列表各不相同参数个数和类型不同Override:子类与父类的某个方法的名称和参数完全相同 2)接口是否可以继承接口?接口是否支持多继承?接口里面是否可以有方法实现 12345接口可以有静态方法和方法体接口中所有的方法必须是抽象方法(jdk8之后就不是)接口不是被类继承而是被类实现一个类只能继承一个类,但是能实现多个接口接口能继承另一个接口 3)jdk8的新特性1234567891011接口中可以有static方法,但必须有方法实现体,该方法只属于该接口,接口名直接调用该方法接口中新增default关键字修饰的方法,只能定义在接口中,可以在子类或子解扣子中被重写default定义的方法必须有方法体父接口的default方法如果在子接口或子类被重写,那么子接口实现对象,子类对象,调用该方法,以重写为准本类,接口如果没有没有重写父类的default方法,则调用时,使用父类定义的default方法逻辑 14.List集合篇1)说下Vector和ArrayList,LinkList联系和区别?分别使用场景1234567ArrayList:底层用数组实现,非线程安全,查询和修改非常快,但是增加和删除慢常用于查询和修改多LinkList:底层是双向链表,非线程安全,查询和修改非常慢,但是增加和删除快常用于增删多Vector :底层数组实现,线程安全,已经很少用了 2)如果需要保证线程安全,ArrayList应该怎么做,有几种方式123方式一:自己写个包装类,根据业务一般是add/update/remove加锁方式二:Collection.synchronize(new ArrayList&lt;&gt;()); 使用synchronize加锁方式三:CopyOnWriteArrayList&lt;&gt;() 使用ReentrantLock加锁 3)了解CopyOnWriteArrayList吗和Collection.synchronize有什么区别?使用场景1234567891011CopyOnWriteArrayList:执行修改操作,会拷贝一份新的数据(add/set/remove),代价昂贵,修改好后会将原来的集合指向新的集合来完成操作,使用ReentrantLock来保证不会多个线程同时修改使用场景: 适合读操作远大于写操作的场景(读操作是不需要加锁的,读多写少)区别: Collection.synchronize线程安全的原因就是几乎每个方法都是synchronize加锁场景:写操作性能比CopyOnWriteArrayList&lt;&gt;()好,但是读操作性能并不如CopyOnWriteArrayListCopyOnWriteArrayList的设计思想是怎样的,有什么缺点?设计思想:读写分离+最终一致缺点:内存占用问题,由于写时复制,内存里面同事存在俩个对象占用的内存,如果对象大则容易发生YongGC和FullGC 4)ArrayList的扩容机制是怎样的?1234注意:Jdk1.7之前的ArrayList的默认大小是10,jdk1.7之后是0未指定大小则集合大小为0,当第一次添加元素的时候集合扩容为10指定大小以后大小为指定容量ArrayList的元素个数大于其容量,扩容的大小=原始大小+原始大小的1/2 5)设计一个简单的ArrayList[需要包含构造参数(有参无参),add(obj),扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * @Author: NineEr * @Date: 2020/3/19 10:59 * @Description: */public class MyArrayList implements Serializable { /* 使用这个字段来判断当前集合类是否被并发修改 即迭代器并发修改的fail-fast机制 */ private transient int modConut = 0; //第一次扩容的容量 private static final int DAFAULT_CAPACITY = 10; //用于初始化空的list private static final Object[] EMPTY_ELEMENT_DATA = {}; //实际存储的元素 transient Object[] elementData; //实际list集合大小,从0开始 private int size; public MyArrayList(){ this.elementData=EMPTY_ELEMENT_DATA; } public MyArrayList(int initialCapctity){ if(initialCapctity&gt;0){ this.elementData = new Object[initialCapctity]; }else if(initialCapctity==0) { this.elementData = EMPTY_ELEMENT_DATA; }else { throw new IllegalArgumentException(\"参数异常\"); } } public boolean add(Object e){ //判断容量 ensureCapacityInternal(size+1); //使用下标赋值,尾部插入 elementData[size++] = e; return true; } //计算容量+确保容量 private void ensureCapacityInternal(int miniCapacity){ //用于并发判断 modConut++; //如果是初次扩容,则使用默认的容量 if(elementData==EMPTY_ELEMENT_DATA){ miniCapacity = Math.max(DAFAULT_CAPACITY,miniCapacity); } //是否需要扩容,需要的最少容量大于现在数组的长度则要扩容 if(miniCapacity - elementData.length&gt;0){ int oldCapacity = elementData.length; int newCapacity = oldCapacity+(oldCapacity&gt;&gt;1); //如果新容量&lt;最小容量,则将最新的容量赋值给新的容量 if(newCapacity - miniCapacity &lt; 0){ newCapacity = miniCapacity; } //创建新数组 Object[] objects = new Object[newCapacity]; //将旧的数组复制到新的数组里面 System.arraycopy(elementData,0,objects,0,elementData.length); //修改引用 elementData = objects; } } /** * 通过下标获得对象 * @param index * @return */ public Object get(int index){ rangeCheck(index); return elementData[index]; } /** * 边界检查 * @param index */ private void rangeCheck(int index) { if(index&gt;size|| size&lt;0){ throw new IndexOutOfBoundsException(\"数组越界\"); } } /** * 判断对象所在位置 * @param o * @return */ public int indexOf(Object o){ if(o==null){ for(int i=0; i&lt;size;i++){ if(elementData[i]==null){ return i; } } }else { for (int i = 0; i &lt; size; i++) { if(o.equals(elementData[i])){ return i; } } } return -1; } /** * @param index * @param obj * @return */ public Object set(int index,Object obj){ rangeCheck(index); Object oldValue = elementData[index]; elementData[index]=obj; return oldValue; } /** * 根据索引删除元素 * @param index * @return */ public Object remove(int index){ //用于并发判断 modConut++; rangeCheck(index); Object oldValue = elementData[index]; //计算要删除的位置后面有几个元素 int numMove = size-index-1; if(numMove&gt;0){ System.arraycopy(elementData,index-1,elementData,index,numMove); } /* * 将多出的位置设置为空没有引用对象 * 垃圾收集器可以回收 * 如果不为空将会保存一个引用 * 可能会导致内存泄漏 */ elementData[--size] =null; return oldValue; } /** * 获取数组实际大小 * @return */ public int size(){ return this.size; }} 15.Map篇1). Map 相关实现12345HashMap Hashtable LinkedMap TreeMap ConcurrentHashMapHashMap 和 Hashtable的区别HashMap :底层是基于数组+链表 非线程安全 默认容量16 允许有空见和值Hashtable:基于哈希表实现 线程安全使用synchronize加锁 默认容量11 不允许有null的键和值 2)对象的比较,排重hashcode和equals的情况 也是map和set里面常用知识123456789101112hashcode :顶级类object里边的方法.返回是一个int类型的数根据一定的hash规则(存储地址,字段,长度等),映射成一个数组,即散列值equals:顶级类object里面的方法,返回的是一个boolean类型根据自定义的匹配规则,用于匹配俩个对象是否一样,一般逻辑如下//判断地址是否一样//非空判断和Class类型判断//强转//对象里面的字段一一匹配使用场景:对象比较,或者集合容器里面排重,比较,排序 3)介绍下对象的hasCode()和equals()使用场景123456789101112131415代码实战:编写一个User对象,重写里面的hashcode和equal方法@Override public boolean equals(Object o) { if (this == o) return true;//比较地址 if (o == null || getClass() != o.getClass()) return false;//判空 User user = (User) o;//当前对象比较 return age == user.age &amp;&amp; name.equals(user.name) &amp;&amp; time.equals(user.time); } @Override public int hashCode() { return Objects.hash(name, age, time); } 4).HashMap和TreeMap该怎么选择12345678910111213HashMap :散列桶 (数组+链表) ,可以实现快速的存储和检索,但是确实包含无序的元素,适用于在map中插入删除和定位元素TreeMap :使用存储结构是一个平衡二叉树-&gt;红黑树,可以自定义排序规则,要实现Comparator接口能便捷的实现内部元素的各种排序,但是一般性能比HashMap差,适用于安装自然排序或者自定义排序规则(微信支付宝签名工具类就用这个类)Set和Map的关系核心: 不保存重复的元素,存储一组唯一的对象set的每一种实现都是对应Map里面的一种封装HashSet对应的就是HashMap,treeSet对应的就是treeMap常见Map的排序规则是怎样的?按照添加顺序使用LinkMap,按照自然排序使用TreeMap,自定义TreeMap(Comparator c ) 5)如果需要线程安全,且效率高的Map,应该怎么做123456多线程环境下可以用concurrent包下的ConcurrentHashMap,或者使用Collections.synchronizeMap().ConcurrentHashMap虽然是线程安全的,但是他的仙侣比Hashtable要高的多为什么Collections.synchronizeMap()是线程安全的因为使用Collections.synchronizeMap()后的map的方法都加锁了 6)HashMap的底层实现,源码1234HashMap底层(数组+链表+红黑树 jdk8才有红黑树)数组中每一项是一个链表 即数组和链表的结合体jdk1.8中,链表的长度大于8,链表会转换成红黑树 7)解释一下hash碰撞,以及解决方法123hash碰撞:不同的key计算得到的hash值相同,需要放到同个bucket中解决办法: 链表法,开发地址法,再哈希法等eg:链表法 hashmap使用的是链表法 8)hashMap底层是数组+链表+红黑树,为什么要用这几类结构呢12345678910111213数组Node&lt;K,V&gt; value 根据对象的key和hash值进行在数组里面是那个节点链表的作用是解决hash冲突,将hash值一样的对象存在一个链表放在hash值对应的曹位红黑树 jdk8使用红黑树来替代超过8个节点的链表 主要是提升查询性能通过hash碰撞,让hashmap不断产生碰撞,那么相同的key的位置的链表就会不断增长,当对这个hashmap的相应位置进行查询的时候,就会循环遍历这个超级大的链表,性能就会下降,所以改用红黑树为什么选择红黑树而不用其他树,比如二叉查找树,为啥不一值开始就用红黑树,而是到8的长度后变换原因:二叉查找树主要是提升查找数据的速度,红黑树是平衡二叉树的一种,插入新数据后通过左旋右旋变色等操作来保持平衡,解决单链表查询深度的问题数据量少的时候操作数据,遍历线性表比红黑树所消耗的资源少,且前期数据少 平衡二叉树保持平衡是需要消耗资源的所以前期采用线性表等到一定数之后变换到红黑树 10)ConcurrentHashMap基础和原理,为什么性能比hashtable高,jdk1.7和jdk1.8的区别123456789101112ConcurrentHashMap:线程安全的Map,hashtable的所有方法都采用Synchronize进行线程安全控制 高并发情况下效率降低但是ConcurrentHashMap是采用分段锁的思想提高性能,锁粒度细化区别:jdk8之前ConcurrentHashMap采用分段锁技术,将数据分成一段段存储,每个数据段配置一把锁即segment类,这个类继承ReentrantLock来保证线程安全技术:Segment+HashEntry在jdk8的版本取消segment这个分段锁数据结构底层也是使用node数组+链表+红黑树,从而实现对每一段数据进行加锁,也减少了并发冲突的概率,CAS(读)+Synchronize(写)技术点: Node+CAS+Synchronized 11)ConcurrentHashMap的基础原理:put1234567891011121314151617//重hash,减少哈希碰撞spread(key.hashCode());//获取索引中下标为i的元素tabAt(i);//乐观锁,利用CAS操作获取table中索引为i的node元素casTabAt(i);put核心流程:1.key进行重哈希spread(key.hashCode());2.对当前table进行无条件循环3.如果没有初始化,则用initTable初始化(采用懒加载模式)4.如果没有hash冲突,则直接用CAS插入新节点,成功后则直接判断是否需要扩容分,然后结束5.(fh=f.hash)==MOVED 如果是这个状态则是扩容操作,先进行扩容6.存在hash冲突,利用synchronize(f)就锁保证线程安全7.如果是链表,则直接遍历插入,如果数量大于8,则需要转换成红黑树8.如果是红黑树则按照红黑树规则插入9.最后检查是否需要扩容addCount(); 16.并发编程1)线程,进程,协程的区别12345678910111213141516171819进程: 本质上是一个独立执行的程序,进程是操作系统进行资源分配和调度的基本概念,操作系统进行资源分配和调度的独立单位线程: 是操作系统能够进行运算调度的最小单位,被包含在进程中,是进程中的实际运作单位,一个进程可以并发多个线程,每条线程执行不同的任务,切换受系统控制协程:又称微线程,是一种用户态的轻量级线程,协程不像线程和进程需要进行系统内核上的上下文切换,协程的上下文切换是用户自己决定的,有自己的上下文,所以说是轻量级的线程,也称之为用户级别的线程就叫协程一个线程可以多个协程,线程进程都是同步机制,而协程则是异步java的原生语法中并没有实现协程,目前py,lua,go支持关系: 一个进程可以有多个线程,它允许计算机同时运行两个或多个程序,一个进程至少会有一个线程 线程是进程的最小执行单位,cpu的调度切换的是进程和线程,进程和线程多了之后调度会消耗大量的额cpu 线程是独立运行和独立调度的基本单位,cpu上真正运行的是线程,线程可以对应多个协程 2)协程对于对于多线程有什么优缺点12345678910优点: 非常快读的上下文切换 不用系统内核的上下文切花 减小开销 单线程即可高并发 单核cpu可以支持上万的协程 由于只有一个线程,也不存在同时写变量的冲突 在协程中控制共享资源不需要加锁缺点: 协程无法利用多核资源 本质就是单个线程 协程需要和进程配合才能运行在多cpu上 目前java没成熟的第三方库 存在风险 调式debug存在难度 不利于发现问题 3)并行和并发的区别12345678910并发: 一台处理器上同时处理任务,这个同时实际上是交替处理多个任务 程序中可以同时拥有两个或者多个线程 当有多个线程在操作时,如果系统中只有一个cpu 则它根本不可能真正同时进行一个以上的线程 它只能把cpu 运行时间划分成若干个时间段 再将时间段分配给各个线程执行 并行: 多个CPU同时处理多个任务,一个cpu执行一个进程时,另一个cpu可以执行另一个进程,两个进程互不抢占cpu资源 可以同时进行 并发指在一段时间内宏观上去处理多个任务 并行指同一时刻,多个任务确实真的同时运行 4)java实现多线程有哪几种放肆,不同,比较 1、继承Thread类创建线程 2、实现Runnable接口创建线程 3、实现Callable接口通过FutureTask包装器来创建Thread线程创建Callable接口的实现类 并实现call方法,结合FutureTask类包装Callable对象实现多线程优点:有返回值,扩展性高缺点:jdk1.5以后才支持 需要重写call方法 结合多个类比如FutureTask和Thread类示例代码: 1234567891011121314151617181920212223242526public static void main(String[] args) { //Mytask mytask = new Mytask(); FutureTask&lt;Object&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Object&gt;() { @Override public Object call() throws Exception { System.out.println(\"Callable实现多线程名称\"+Thread.currentThread().getName()); return \"callThread\"; } }); //FutureTask实现了Runnable接口可以放在Thread中启动执行 Thread thread = new Thread(futureTask); thread.setName(\"demo\"); thread.start(); System.out.println(\"主线程名称\"+Thread.currentThread().getName()); try { System.out.println(futureTask.get()); } catch (InterruptedException e) { //阻塞等待中被中断抛出 e.printStackTrace(); } catch (ExecutionException e) { //阻塞等待中被中断,则抛出 e.printStackTrace(); } } 4、通过线程池创建自定义Runnable接口 实现run方法 创建线程池 调用执行方法并传入对象优点:安全高性能 复用线程缺点:jdk 5后才支持 需要结合Runnable进行使用示例代码: 123456789public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) { executorService.execute(new ThreadPoolDemo()); } System.out.println(\"主线程名称:\"+Thread.currentThread().getName()); //关闭线程池 executorService.shutdown(); } 一般常用的第二种和第四种Runnable和线程池+Runnable 简单方便扩展 和高性能 (池化思想) 5)线程状态有哪些?123456789101112131415jdk的线程分6种,jvm有9种(一般说jdk)常见的5种状态* 创建(new): 生成线程对象 但是并没有调用该对象start(),new Thread()* 就绪(Runnable): 1)调用线程对象的start()方法 线程就进入就绪状态 2)线程运行后,从等待和睡眠中回来进入就绪状态 但是此时线程调度还没有切换到当前线程,没有获取cpu使用权 只是有机会得到调度 * 运行(running): 程序就绪, cpu切换至当前线程进入运行状态* 阻塞(blocked): 1)等待阻塞: 需要等待其他线程做出一定动作(通知或中断),这种情况下cpu不会分配过来需要被唤醒,也可能无限等待,wait()或者sleep(),join或者发出io请求 阻塞结束后线程重新进入就绪状态 2)同步阻塞: 线程在获取synchronized同步所失败,即被其他线程占用 就会进入同步阻塞 * 死亡(terminal): 一个线程run方法执行结束 不能重新进入运行状态 6)线程的常见方法1234567891011Thread自带方法:sleep(): 交出cpu的使用权,等待预计时间之后再恢复 不会释放锁 进入阻塞状态 睡眠结束变为就绪Runnableyield(): 属于线程Thread的方法 暂停当前线程对象 去执行其他对象 让相同优先级的线程先执行 不会让线程进入阻塞状态 直接变为就绪Runnable 只需要重新获得cpu使用权join(): 在主线程上调用该方法会让主线程休眠 不会释放已经持有的对象锁 让调用join方法的线程先执行完毕 再执行其他线程 类似于救护车Object顶级类带的方法:wait(): 当前线程调用对象wait方法 会释放锁 进入线程的等待队列 需要依靠notify|notifyall唤醒notify(): 唤醒在对象监视器上等待的单个线程 选择是任意的notifyAll(): 唤醒在对象监视器上等待的全部线程 7)业务代码中的多线程,业务场景12345678910111213 异步任务: 用户注册 记录日志 定时任务:定期备份日志 备份数据库 分布式计算: Hadoop处理任务mapreduce master-wark单机单进程 服务器编程: Socket网络编程 一个连接一个线程* 不是线程安全的数据结构HashMap ArrayList LinkedList* java中可以有哪些方法来保证线程安全加锁 比如synchronize/ReentrantLock使用volatile声明变量 轻量级同步 不能保证原子性使用线程安全类(并发容器,原子类,同步容器 CopyOnWriteArrayList/... Thread 本地私有变量等) 8)volatile关键字?与synchronize的区别1234567扩展:1、原子性即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断 要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。2、可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 1234567891011volatile: 是轻量级的synchronize 保证了共享变量的可见性,被它修饰的变量 如果值发生改变其他线程立刻可见,避免出现藏独线程 保证可见性 但是不能保证原子性 synchronize: 保证可见性 也保证原子性使用场景:1.不能修饰写入操作依赖当前值的变量 比如num++,num=num+1,不是原子操作 肉眼看起来是但是jvm字节码层面不止一步2.由于禁止了指令重排所以jvm相关的优化没了效率会偏弱 9)为什么会出现脏读?123456java内存模型简称 JMMJMM规定所以的变量存在主内存 每个线程有自己的工作内存 线程对变量的操作都在工作内存中进行 不能直接对主内存进行操作使用volatile修饰变量 每次读取钱必须从主内存属性获取最新的值每次写入需要立刻写到主内存中 10)什么是指令重排？1234567指令重排序分俩类: 编译器重排序和运行时重排序JVm编译java代码或者CPU执行JVM字节码时,对现有指令进行重新排序,主要目的是优化运行效率(不改变程序结果的前提)虽然指令重排序可以提高执行效率但是多线程上可能会影响结果有什么解决办法?解决办法:内存屏障解释: 内存屏障是屏障指令 是cpu对屏障指令之前和之后的内存操作执行结果的一种约束 11)happens-before吗,能否简单解释下?12345678910先行发生原则,volatile的内存可见性体现了该原则之一八大原则:1.程序次序规则2.管理锁定规则3.volatile变量规则4.线程启动规则5.线程中断规则6.线程终止规则7.对象终结规则8.传递性 17并发编程进阶1)并发编程三要素 123456789101112131415161718192021222324252627281.原子性: 要么全部执行 要么全部执行失败private int num =0; ReentrantLock lock = new ReentrantLock(); public void add(){ lock.lock(); try { num++; }finally { lock.unlock(); } } //使用synchronized和上述是一个操作 这个是保证方法被锁住 上述是代码块被锁住 public synchronized void put(){ num++; }不能存在上下文切换,线程会带来原子性的问题解决办法是可以用synchronize或lock(比如ReetrantLock)来吧这个多操作变成原子性操作但是volatile,前面有说道不能修饰有依赖值的情况解决方法的核心思想:把一个方法或者代码块看做一个整体 保证是一个不可分割的整体2.有序性解决方式:加锁禁止指令重排3.可见性同样加锁synchronize或lock或者validate能够保证线程可见性 2进程间的调度算法1234567891011121314151617181920211.先来先服务调度算法: 按照作业/进制程到达的先后顺序 排在长进程后的短进程的等待时间长 不利于短作业2.短作业优先调度算法 短作业在实际情况中占有很大比例 对长作业不友好3.高响应比优先调度算法 在每次调度时,先计算各个作业的优先权 优先权: 优先权= 响应比=(等待时间+要求服务时间)/要求服务时间 需要计算优先权信息,增减了系统开销4.时间片轮调度算法 轮流的为各个进程服务,让每个进程在一定时间间隔内都可以得到响应 由于高频率的进程切换增加了系统开销,并且不区分任务的紧急程度 5.优先级调度算法 根据任务的紧急程度进行调度 高优先级的先处理 如果高优先级任务很多且持续产生 那么低优先级的可能很慢才被处理 每种算法都有他的优缺点根据业务选择 3)线程间的调度算法 java是哪种123456789101112131415线程调度时指系统为线程分噢诶cpu使用权的过程,主要分为两种1.协同式线程调度(分时调度模式): 线程执行时间自由由线程本身来控制 线程把自己的工作执行完之后 要主动通知系统切换倒另外一个线程上 最大好处是实现简单 且切换操作对线程自己是可知的 没有线程同步问题 坏处是线程执行时间不可控制 如果一个线程有问题 可能一直阻塞在那里2.抢占式线程调度: 每个贤臣由系统分配执行时间 线程的切换不由线程本身来决定可以让出执行时间 但无法获取执行时间 线程执行时间系统可控 也不会有一个线程导致整个进程阻塞java是抢占式调度,优先让可运行池中优先级高的线程占用cpu 如果可运行池中的线程优先级相同 那就随机选择一个线程wait() ,notify()看上去是线程本身控制其实不是,是随机在队列中获取而已 4)java中常用的锁1234567891011121314151617悲观锁: (和乐观锁成对出现,乐观锁: 每次获取数据时都认为别人不会修改,更新的时候回去判断是否更新数据,通过版本判断,数据修改就拒绝更新,比如CAS是乐观锁)悲观锁:当线程去操作数据时,总认为背的线程会去修改数据所以每次它拿数据的时候都会上锁别的线程就会阻塞公平锁: 指多个线程按照申请锁的顺序来获取锁 简单来说如果一个线程组里 能保证每个线程都能拿到锁 比如ReentrantLock,底层是同步队列FIFO:First Input First OUtput来实现的非公平锁:获取锁的方式是随机获取的 保证不了每个线程都能拿到锁 也就存在有线程饿死拿不到锁的情况小结: 非公平锁性能高于公平锁 能重复利用cpu时间可重入锁: 也叫递归锁 在外层使用锁以后内层仍然可以使用 并且不发生死锁不可重入锁: 若当前线程执行某个方法以及获得了该锁 那么在方法中尝试再次获取锁时就会被阻塞小结: 可重入锁能一定程度的避免死锁 synchronize ReentrantLock 自旋锁: 一个线程在获取锁的时候 如果锁已经被其他线程获取 那么该线程循环等待 然后不断的判断是否锁能被成功获取直到获取到锁才会退出循环 任何时刻最低只能有一个执行单元获得锁小结: 不会发生线程状态的奇幻 一直处于用户态 减少了线程上下文的切换的消耗 缺点是循环会消耗cpu常见的自旋锁: TicketLock CLHLock MSCLock 5)日常开发用过的锁123456789101112共享锁: 也叫s锁/读锁 能查看但无法修改和删除数据的一种数据锁 加锁后其他用户可以并发读取查询数据但是不能修改 增加,删除数据,该锁可被多个线程所持有 用于资源共享互斥锁: 也叫X锁/排他锁/写锁/独占锁/独享锁 该锁每一次只能被一个线程所持有 加锁后任何线程试图再次加锁都会被 阻塞,直到当前线程解锁 死锁: 俩个或俩个以上的线程在执行过程中由于竞争资源或者由于彼此通信而造成的一种阻塞的现象若无外力作用 将无法让程序继续进行jvm锁的升级:synchronize-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁其他锁: 分段锁, 行锁,表锁 6)手写死锁12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<h1 id=\"基础知识复习笔记\"><a href=\"#基础知识复习笔记\" class=\"headerlink\" title=\"基础知识复习笔记\"></a>基础知识复习笔记</h1><blockquote>\n<p>有错误的地方还请多多指教  （未完待续）</p>\n</blockquote>\n<h3 id=\"1-运算符-amp-和-amp-amp-和-的区别\"><a href=\"#1-运算符-amp-和-amp-amp-和-的区别\" class=\"headerlink\" title=\"1. 运算符&amp;和&amp;&amp;,|和||的区别\"></a>1. 运算符&amp;和&amp;&amp;,|和||的区别</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;:按位与操作 只有对应的2个二进制数都为1才为1</span><br><span class=\"line\">&amp;和&amp;&amp;的区别</span><br><span class=\"line\">&amp;俩边都运算,&amp;&amp;从左边开始运算,当左侧为false则右侧不运算</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|按位或,有一个为1则为1</span><br><span class=\"line\">|和||的区别</span><br><span class=\"line\">和上面类似,只要左侧满足条件后面就不再判断</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;&amp;和||为短路运算符</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"2-用最有效的方法计算2-8\"><a href=\"#2-用最有效的方法计算2-8\" class=\"headerlink\" title=\"2. 用最有效的方法计算2*8\"></a>2. 用最有效的方法计算2*8</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原理:将一个数左移n位,相当于*2的n次方,位运算是cpu直接支持的所以效率高</span><br><span class=\"line\">2&lt;&lt;3</span><br><span class=\"line\"></span><br><span class=\"line\">常见的HashMap的默认容量16</span><br><span class=\"line\">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class=\"line\">直接二进制操作,表示1左移4位,编程10000,转为10进制也就是16</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-写个方法-传递来个非0的int数值-实现变量交换的方式有几种\"><a href=\"#3-写个方法-传递来个非0的int数值-实现变量交换的方式有几种\" class=\"headerlink\" title=\"3.写个方法,传递来个非0的int数值,实现变量交换的方式有几种?\"></a>3.写个方法,传递来个非0的int数值,实现变量交换的方式有几种?</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方式一:</span><br><span class=\"line\">public static void swap(int a,int b){</span><br><span class=\"line\">        a = a+b;</span><br><span class=\"line\">        b = a-b;</span><br><span class=\"line\">        a = a-b;</span><br><span class=\"line\">    }</span><br><span class=\"line\">方法二(异或运算,一个数与另一个数异或俩次是其本身,一个数和自身异或结果是0):</span><br><span class=\"line\"> public static void swap2(int a,int b){</span><br><span class=\"line\">        System.out.println(\"a:\"+a+\",b:\"+b);</span><br><span class=\"line\">        a = a^b;</span><br><span class=\"line\">        b = b^a;</span><br><span class=\"line\">        a = a^b;</span><br><span class=\"line\">        System.out.println(\"a:\"+a+\",b:\"+b);</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"4-try-catch-finally语句块-catch的return与finally的return返回值\"><a href=\"#4-try-catch-finally语句块-catch的return与finally的return返回值\" class=\"headerlink\" title=\"4.try-catch-finally语句块,catch的return与finally的return返回值\"></a>4.try-catch-finally语句块,catch的return与finally的return返回值</h3><p>最终返回值的确定:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在执行try,catch中的return之前一定会执行finally中的代码,(如果finally存在)</span><br><span class=\"line\">如果finally中有return语句,就会执行执行finally中的return方法,</span><br><span class=\"line\">所以finally中的return语句一定会被执行</span><br><span class=\"line\"></span><br><span class=\"line\">执行流程:</span><br><span class=\"line\">finally执行前的代码有包含return,则会先确定return返回值,</span><br><span class=\"line\">然后再执行finally的代码最后再执行return</span><br><span class=\"line\">(如果finally代码块中 没有新的return那么就会返回原来确定好的return值)</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-说下java数据类型分类\"><a href=\"#5-说下java数据类型分类\" class=\"headerlink\" title=\"5.说下java数据类型分类\"></a>5.说下java数据类型分类</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1)基础数据类型</span><br><span class=\"line\"> byte short int long float double char boolean</span><br><span class=\"line\">2)引用数据类型</span><br><span class=\"line\">其他都是引用类型(比如String和Enum)</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-运算\"><a href=\"#6-运算\" class=\"headerlink\" title=\"6.运算\"></a>6.运算</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义变量 int i =5</span><br><span class=\"line\">return i++;</span><br><span class=\"line\"></span><br><span class=\"line\">return ++i;</span><br><span class=\"line\">返回值分别为5,6</span><br><span class=\"line\"></span><br><span class=\"line\">i++先返回i再运算</span><br><span class=\"line\">++I先运算再返回</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"7-和equals的区别\"><a href=\"#7-和equals的区别\" class=\"headerlink\" title=\"7.== 和equals的区别\"></a>7.== 和equals的区别</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本数据类型比较 用==判断</span><br><span class=\"line\">引用数据类似: ==比较的是内存地址是否一样,不同对象的内存地址不一样,</span><br><span class=\"line\">equals比较的是具体的内容,也可以让开发者去定义什么条件判断俩个对象是否一样</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"8-新版jdk处理io流-编写基础代码从一个txt文本里边拷贝文本到另外一个文本\"><a href=\"#8-新版jdk处理io流-编写基础代码从一个txt文本里边拷贝文本到另外一个文本\" class=\"headerlink\" title=\"8.新版jdk处理io流:编写基础代码从一个txt文本里边拷贝文本到另外一个文本\"></a>8.新版jdk处理io流:编写基础代码从一个txt文本里边拷贝文本到另外一个文本</h3><p>try-with-resources</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdk7之后的写法,jdk9进行了改良,主要记住下面的写法,需要关闭的资源只要执行了</span><br><span class=\"line\">java.io.Closeable,就可以自动被关闭,try()可以定义多个资源,他们的关闭顺序是后</span><br><span class=\"line\">在try里边定义的最新关闭</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try {</span><br><span class=\"line\">            FileInputStream fis = new FileInputStream(\"D:/Readme.txt\");</span><br><span class=\"line\">            BufferedInputStream bis = new BufferedInputStream(fis);</span><br><span class=\"line\"></span><br><span class=\"line\">            FileOutputStream fos = new FileOutputStream(\"D:/Copy.txt\");</span><br><span class=\"line\">            BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class=\"line\"></span><br><span class=\"line\">            int size;</span><br><span class=\"line\">            byte[] buf = new byte[1024];</span><br><span class=\"line\">            while ((size = bis.read(buf))!=-1){</span><br><span class=\"line\">                bos.write(buf,0,size);</span><br><span class=\"line\">            }</span><br><span class=\"line\"></span><br><span class=\"line\">        } catch (FileNotFoundException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        } catch (IOException e) {</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        }</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"9-常见API和递归算法的考察\"><a href=\"#9-常见API和递归算法的考察\" class=\"headerlink\" title=\"9.常见API和递归算法的考察\"></a>9.常见API和递归算法的考察</h3><p>:找出某目录下的所有子目录以及子文件并打印在控制台上</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) {</span><br><span class=\"line\">        ArrayList&lt;String&gt; paths = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">        getAllFilePaths(new File(\"D:\\\\DeveloperTools\\\\Git\"),paths);</span><br><span class=\"line\">        for (String path : paths) {</span><br><span class=\"line\">            System.out.println(path);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void getAllFilePaths(File filePaths, ArrayList&lt;String&gt; paths) {</span><br><span class=\"line\">        File[] files = filePaths.listFiles();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (files==null){</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        }else{</span><br><span class=\"line\">            for (File file : files) {</span><br><span class=\"line\">                if(file.isDirectory()){</span><br><span class=\"line\">                    paths.add(file.getPath());</span><br><span class=\"line\">                    getAllFilePaths(file,paths);</span><br><span class=\"line\">                }else {</span><br><span class=\"line\">                    paths.add(file.getPath());</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"10-常用字符串知识点\"><a href=\"#10-常用字符串知识点\" class=\"headerlink\" title=\"10.常用字符串知识点\"></a>10.常用字符串知识点</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1)String str = new String(\"abc.net\")创建了几个对象?</span><br><span class=\"line\">如果常量池存在,则直接在堆里new一个对象</span><br><span class=\"line\">如果常量池不存在,则在常量池创建一个对象,也在堆里创建一个对象</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2) 下面比较是比较什么?输出什么?为什么这样</span><br><span class=\"line\">        String s1 = \"abc\";</span><br><span class=\"line\">        String s2 = \"abc\";</span><br><span class=\"line\">        String s3= new String(\"abc\");</span><br><span class=\"line\">        System.out.println(\"s1 == s2 ? \"+(s1==s2)); //true</span><br><span class=\"line\">        System.out.println(\"s1 == s3 ? \"+(s1==s3)); //false</span><br><span class=\"line\">        System.out.println(\"s1 equals s3 ? \"+(s1.equals(s3))); //true</span><br><span class=\"line\">有两种方式判断字符串是否相等，使用”==”或者使用equals方法。当使用”==”操作符</span><br><span class=\"line\">不仅比较字符串的值，还会比较引用的内存地址。大多数情况下，我们只需要判断值</span><br><span class=\"line\">是否相等，此时用equals方法比较即可。</span><br><span class=\"line\">还有一个equalsIgnoreCase可以用来忽略大小写进行比较。</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3)写出下面代码的结果?如果需要俩个都为true,应该怎么修改</span><br><span class=\"line\">String s1 =\"abc\";</span><br><span class=\"line\">String s2 =s1+\".net\";     //变量+常量 = 来自堆</span><br><span class=\"line\">String s3 =\"abc\"+\".net\"; //常量+常量  =来自常量池</span><br><span class=\"line\"> System.out.println(s2 == \"abc.net\"); //false</span><br><span class=\"line\"> System.out.println(\"s3 == \"abc.net\"); //true</span><br><span class=\"line\"> </span><br><span class=\"line\"> 修改: final String s1 =\"abc\";即可 将变量改成常量</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"11-String-StringBuffer与StringBuilder的区别-使用场景\"><a href=\"#11-String-StringBuffer与StringBuilder的区别-使用场景\" class=\"headerlink\" title=\"11.String ,StringBuffer与StringBuilder的区别?使用场景\"></a>11.String ,StringBuffer与StringBuilder的区别?使用场景</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相同:</span><br><span class=\"line\">三者都是final类 不允许被继承,底层都是cha[]数组实现</span><br><span class=\"line\">String是不可变对象,其他俩个是可变的</span><br><span class=\"line\">使用</span><br><span class=\"line\">StringBuilder 效率快,不需要加锁不具备线程安全,不在多线程情况下使用</span><br><span class=\"line\">StringBuffer 用synchronize加锁,效率低,线程安全</span><br><span class=\"line\"></span><br><span class=\"line\">场景:</span><br><span class=\"line\">操作少量数用String</span><br><span class=\"line\">单线程下用StringBuilder,虽然线程不安全但是效率高</span><br><span class=\"line\">多线程情况下操作大量的字符串,且需要保证线程安全用StringBuffer</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"12-面向对象OOP思想-四大特性-分别解释\"><a href=\"#12-面向对象OOP思想-四大特性-分别解释\" class=\"headerlink\" title=\"12.面向对象OOP思想,四大特性,分别解释\"></a>12.面向对象OOP思想,四大特性,分别解释</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">抽象:abstract 声明的类和方法 共性又可变</span><br><span class=\"line\">封装:private /protected /public 加强安全性</span><br><span class=\"line\">继承:extend 具有公共的方法和属性 </span><br><span class=\"line\">多态:同一行为具有不同的表现形式,减少耦合,灵活可配</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"13-接口篇\"><a href=\"#13-接口篇\" class=\"headerlink\" title=\"13.接口篇\"></a>13.接口篇</h3><h4 id=\"1-Overload和Override区别\"><a href=\"#1-Overload和Override区别\" class=\"headerlink\" title=\"1).Overload和Override区别?\"></a>1).Overload和Override区别?</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Overload:</span><br><span class=\"line\">在同一个类可以有多个名称相同的方法,但是这些方法的参数列表各不相同</span><br><span class=\"line\">参数个数和类型不同</span><br><span class=\"line\"></span><br><span class=\"line\">Override:</span><br><span class=\"line\">子类与父类的某个方法的名称和参数完全相同</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"2-接口是否可以继承接口-接口是否支持多继承\"><a href=\"#2-接口是否可以继承接口-接口是否支持多继承\" class=\"headerlink\" title=\"2)接口是否可以继承接口?接口是否支持多继承?\"></a>2)接口是否可以继承接口?接口是否支持多继承?</h5><p>接口里面是否可以有方法实现</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接口可以有静态方法和方法体</span><br><span class=\"line\">接口中所有的方法必须是抽象方法(jdk8之后就不是)</span><br><span class=\"line\">接口不是被类继承而是被类实现</span><br><span class=\"line\">一个类只能继承一个类,但是能实现多个接口</span><br><span class=\"line\">接口能继承另一个接口</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"3-jdk8的新特性\"><a href=\"#3-jdk8的新特性\" class=\"headerlink\" title=\"3)jdk8的新特性\"></a>3)jdk8的新特性</h5><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接口中可以有static方法,但必须有方法实现体,该方法只属于该接口,接口名直接调用</span><br><span class=\"line\">该方法</span><br><span class=\"line\"></span><br><span class=\"line\">接口中新增default关键字修饰的方法,只能定义在接口中,可以在子类或子解扣子中</span><br><span class=\"line\">被重写default定义的方法必须有方法体</span><br><span class=\"line\"></span><br><span class=\"line\">父接口的default方法如果在子接口或子类被重写,那么子接口实现对象,子类对象,</span><br><span class=\"line\">调用该方法,以重写为准</span><br><span class=\"line\"></span><br><span class=\"line\">本类,接口如果没有没有重写父类的default方法,则调用时,使用父类定义的default</span><br><span class=\"line\">方法逻辑</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"14-List集合篇\"><a href=\"#14-List集合篇\" class=\"headerlink\" title=\"14.List集合篇\"></a>14.List集合篇</h3><h4 id=\"1-说下Vector和ArrayList-LinkList联系和区别-分别使用场景\"><a href=\"#1-说下Vector和ArrayList-LinkList联系和区别-分别使用场景\" class=\"headerlink\" title=\"1)说下Vector和ArrayList,LinkList联系和区别?分别使用场景\"></a>1)说下Vector和ArrayList,LinkList联系和区别?分别使用场景</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList:底层用数组实现,非线程安全,查询和修改非常快,但是增加和删除慢</span><br><span class=\"line\">常用于查询和修改多</span><br><span class=\"line\"></span><br><span class=\"line\">LinkList:底层是双向链表,非线程安全,查询和修改非常慢,但是增加和删除快</span><br><span class=\"line\">常用于增删多</span><br><span class=\"line\"></span><br><span class=\"line\">Vector :底层数组实现,线程安全,已经很少用了</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"2-如果需要保证线程安全-ArrayList应该怎么做-有几种方式\"><a href=\"#2-如果需要保证线程安全-ArrayList应该怎么做-有几种方式\" class=\"headerlink\" title=\"2)如果需要保证线程安全,ArrayList应该怎么做,有几种方式\"></a>2)如果需要保证线程安全,ArrayList应该怎么做,有几种方式</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方式一:自己写个包装类,根据业务一般是add/update/remove加锁</span><br><span class=\"line\">方式二:Collection.synchronize(new ArrayList&lt;&gt;()); 使用synchronize加锁</span><br><span class=\"line\">方式三:CopyOnWriteArrayList&lt;&gt;() 使用ReentrantLock加锁</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-了解CopyOnWriteArrayList吗和Collection-synchronize有什么区别-使用场景\"><a href=\"#3-了解CopyOnWriteArrayList吗和Collection-synchronize有什么区别-使用场景\" class=\"headerlink\" title=\"3)了解CopyOnWriteArrayList吗和Collection.synchronize有什么区别?使用场景\"></a>3)了解CopyOnWriteArrayList吗和Collection.synchronize有什么区别?使用场景</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CopyOnWriteArrayList:执行修改操作,会拷贝一份新的数据(add/set/remove),代价昂贵,</span><br><span class=\"line\">修改好后会将原来的集合指向新的集合来完成操作,使用ReentrantLock来保证不会多个线程</span><br><span class=\"line\">同时修改</span><br><span class=\"line\">使用场景: 适合读操作远大于写操作的场景(读操作是不需要加锁的,读多写少)</span><br><span class=\"line\">区别: Collection.synchronize线程安全的原因就是几乎每个方法都是synchronize加锁</span><br><span class=\"line\">场景:写操作性能比CopyOnWriteArrayList&lt;&gt;()好,但是读操作性能并不如CopyOnWriteArrayList</span><br><span class=\"line\"></span><br><span class=\"line\">CopyOnWriteArrayList的设计思想是怎样的,有什么缺点?</span><br><span class=\"line\">设计思想:读写分离+最终一致</span><br><span class=\"line\">缺点:内存占用问题,由于写时复制,内存里面同事存在俩个对象占用的内存,如果对象大则容易</span><br><span class=\"line\">发生YongGC和FullGC</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"4-ArrayList的扩容机制是怎样的\"><a href=\"#4-ArrayList的扩容机制是怎样的\" class=\"headerlink\" title=\"4)ArrayList的扩容机制是怎样的?\"></a>4)ArrayList的扩容机制是怎样的?</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意:Jdk1.7之前的ArrayList的默认大小是10,jdk1.7之后是0</span><br><span class=\"line\">未指定大小则集合大小为0,当第一次添加元素的时候集合扩容为10</span><br><span class=\"line\">指定大小以后大小为指定容量</span><br><span class=\"line\">ArrayList的元素个数大于其容量,扩容的大小=原始大小+原始大小的1/2</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"5-设计一个简单的ArrayList-需要包含构造参数-有参无参-add-obj-扩容\"><a href=\"#5-设计一个简单的ArrayList-需要包含构造参数-有参无参-add-obj-扩容\" class=\"headerlink\" title=\"5)设计一个简单的ArrayList[需要包含构造参数(有参无参),add(obj),扩容\"></a>5)设计一个简单的ArrayList[需要包含构造参数(有参无参),add(obj),扩容</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @Author: NineEr</span><br><span class=\"line\"> * @Date: 2020/3/19 10:59</span><br><span class=\"line\"> * @Description:</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MyArrayList implements Serializable {</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    使用这个字段来判断当前集合类是否被并发修改</span><br><span class=\"line\">    即迭代器并发修改的fail-fast机制</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private transient int modConut = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    //第一次扩容的容量</span><br><span class=\"line\">    private static final int DAFAULT_CAPACITY = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    //用于初始化空的list</span><br><span class=\"line\">    private static final Object[] EMPTY_ELEMENT_DATA = {};</span><br><span class=\"line\"></span><br><span class=\"line\">    //实际存储的元素</span><br><span class=\"line\">    transient  Object[] elementData;</span><br><span class=\"line\"></span><br><span class=\"line\">    //实际list集合大小,从0开始</span><br><span class=\"line\">    private int size;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyArrayList(){</span><br><span class=\"line\">        this.elementData=EMPTY_ELEMENT_DATA;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyArrayList(int initialCapctity){</span><br><span class=\"line\">        if(initialCapctity&gt;0){</span><br><span class=\"line\">            this.elementData = new Object[initialCapctity];</span><br><span class=\"line\">        }else if(initialCapctity==0) {</span><br><span class=\"line\">            this.elementData = EMPTY_ELEMENT_DATA;</span><br><span class=\"line\">        }else {</span><br><span class=\"line\">            throw new IllegalArgumentException(\"参数异常\");</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean add(Object e){</span><br><span class=\"line\">        //判断容量</span><br><span class=\"line\">        ensureCapacityInternal(size+1);</span><br><span class=\"line\">        //使用下标赋值,尾部插入</span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    //计算容量+确保容量</span><br><span class=\"line\">    private void ensureCapacityInternal(int miniCapacity){</span><br><span class=\"line\">        //用于并发判断</span><br><span class=\"line\">        modConut++;</span><br><span class=\"line\"></span><br><span class=\"line\">        //如果是初次扩容,则使用默认的容量</span><br><span class=\"line\">        if(elementData==EMPTY_ELEMENT_DATA){</span><br><span class=\"line\">            miniCapacity = Math.max(DAFAULT_CAPACITY,miniCapacity);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        //是否需要扩容,需要的最少容量大于现在数组的长度则要扩容</span><br><span class=\"line\">        if(miniCapacity - elementData.length&gt;0){</span><br><span class=\"line\">            int oldCapacity = elementData.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            int newCapacity = oldCapacity+(oldCapacity&gt;&gt;1);</span><br><span class=\"line\">            //如果新容量&lt;最小容量,则将最新的容量赋值给新的容量</span><br><span class=\"line\">            if(newCapacity - miniCapacity &lt; 0){</span><br><span class=\"line\">                newCapacity = miniCapacity;</span><br><span class=\"line\">            }</span><br><span class=\"line\"></span><br><span class=\"line\">            //创建新数组</span><br><span class=\"line\">            Object[] objects = new Object[newCapacity];</span><br><span class=\"line\">            //将旧的数组复制到新的数组里面</span><br><span class=\"line\">            System.arraycopy(elementData,0,objects,0,elementData.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            //修改引用</span><br><span class=\"line\">            elementData = objects;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 通过下标获得对象</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Object get(int index){</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\">        return elementData[index];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 边界检查</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void rangeCheck(int index) {</span><br><span class=\"line\">        if(index&gt;size|| size&lt;0){</span><br><span class=\"line\">            throw new IndexOutOfBoundsException(\"数组越界\");</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 判断对象所在位置</span><br><span class=\"line\">     * @param o</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int indexOf(Object o){</span><br><span class=\"line\">        if(o==null){</span><br><span class=\"line\">            for(int i=0; i&lt;size;i++){</span><br><span class=\"line\">                if(elementData[i]==null){</span><br><span class=\"line\">                    return i;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }else {</span><br><span class=\"line\">            for (int i = 0; i &lt; size; i++) {</span><br><span class=\"line\">                if(o.equals(elementData[i])){</span><br><span class=\"line\">                    return i;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     * @param obj</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Object set(int index,Object obj){</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\">        Object oldValue = elementData[index];</span><br><span class=\"line\">        elementData[index]=obj;</span><br><span class=\"line\">        return oldValue;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 根据索引删除元素</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Object remove(int index){</span><br><span class=\"line\"></span><br><span class=\"line\">        //用于并发判断</span><br><span class=\"line\">        modConut++;</span><br><span class=\"line\"></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\">        Object oldValue = elementData[index];</span><br><span class=\"line\">        //计算要删除的位置后面有几个元素</span><br><span class=\"line\">        int numMove = size-index-1;</span><br><span class=\"line\">        if(numMove&gt;0){</span><br><span class=\"line\">          System.arraycopy(elementData,index-1,elementData,index,numMove);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * 将多出的位置设置为空没有引用对象</span><br><span class=\"line\">         * 垃圾收集器可以回收</span><br><span class=\"line\">         * 如果不为空将会保存一个引用</span><br><span class=\"line\">         * 可能会导致内存泄漏</span><br><span class=\"line\">         */</span><br><span class=\"line\">        elementData[--size] =null;</span><br><span class=\"line\">        return oldValue;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取数组实际大小</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int size(){</span><br><span class=\"line\">        return this.size;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"15-Map篇\"><a href=\"#15-Map篇\" class=\"headerlink\" title=\"15.Map篇\"></a>15.Map篇</h3><h4 id=\"1-Map-相关实现\"><a href=\"#1-Map-相关实现\" class=\"headerlink\" title=\"1). Map 相关实现\"></a>1). Map 相关实现</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap Hashtable LinkedMap TreeMap ConcurrentHashMap</span><br><span class=\"line\"></span><br><span class=\"line\">HashMap 和 Hashtable的区别</span><br><span class=\"line\">HashMap :底层是基于数组+链表 非线程安全 默认容量16 允许有空见和值</span><br><span class=\"line\">Hashtable:基于哈希表实现 线程安全使用synchronize加锁 默认容量11 不允许有null的键和值</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"2-对象的比较-排重hashcode和equals的情况-也是map和set里面常用知识\"><a href=\"#2-对象的比较-排重hashcode和equals的情况-也是map和set里面常用知识\" class=\"headerlink\" title=\"2)对象的比较,排重hashcode和equals的情况 也是map和set里面常用知识\"></a>2)对象的比较,排重hashcode和equals的情况 也是map和set里面常用知识</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcode :</span><br><span class=\"line\">顶级类object里边的方法.返回是一个int类型的数</span><br><span class=\"line\">根据一定的hash规则(存储地址,字段,长度等),映射成一个数组,即散列值</span><br><span class=\"line\"></span><br><span class=\"line\">equals:</span><br><span class=\"line\">顶级类object里面的方法,返回的是一个boolean类型</span><br><span class=\"line\">根据自定义的匹配规则,用于匹配俩个对象是否一样,一般逻辑如下</span><br><span class=\"line\">//判断地址是否一样</span><br><span class=\"line\">//非空判断和Class类型判断</span><br><span class=\"line\">//强转</span><br><span class=\"line\">//对象里面的字段一一匹配</span><br><span class=\"line\">使用场景:对象比较,或者集合容器里面排重,比较,排序</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-介绍下对象的hasCode-和equals-使用场景\"><a href=\"#3-介绍下对象的hasCode-和equals-使用场景\" class=\"headerlink\" title=\"3)介绍下对象的hasCode()和equals()使用场景\"></a>3)介绍下对象的hasCode()和equals()使用场景</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码实战:编写一个User对象,重写里面的hashcode和equal方法</span><br><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean equals(Object o) {</span><br><span class=\"line\">        if (this == o) return true;//比较地址</span><br><span class=\"line\">        if (o == null || getClass() != o.getClass()) return false;//判空</span><br><span class=\"line\">        User user = (User) o;//当前对象比较</span><br><span class=\"line\">        return age == user.age &amp;&amp;</span><br><span class=\"line\">                name.equals(user.name) &amp;&amp;</span><br><span class=\"line\">                time.equals(user.time);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int hashCode() {</span><br><span class=\"line\">        return Objects.hash(name, age, time);</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"4-HashMap和TreeMap该怎么选择\"><a href=\"#4-HashMap和TreeMap该怎么选择\" class=\"headerlink\" title=\"4).HashMap和TreeMap该怎么选择\"></a>4).HashMap和TreeMap该怎么选择</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap :散列桶 (数组+链表) ,可以实现快速的存储和检索,但是确实包含无序的元素,适用于在map中插入删除和定位元素</span><br><span class=\"line\">TreeMap :使用存储结构是一个平衡二叉树-&gt;红黑树,可以自定义排序规则,要实现Comparator接口</span><br><span class=\"line\">能便捷的实现内部元素的各种排序,但是一般性能比HashMap差,适用于安装自然排序或者自定义排序规则</span><br><span class=\"line\">(微信支付宝签名工具类就用这个类)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Set和Map的关系</span><br><span class=\"line\">核心: 不保存重复的元素,存储一组唯一的对象</span><br><span class=\"line\">set的每一种实现都是对应Map里面的一种封装</span><br><span class=\"line\">HashSet对应的就是HashMap,treeSet对应的就是treeMap</span><br><span class=\"line\"></span><br><span class=\"line\">常见Map的排序规则是怎样的?</span><br><span class=\"line\">按照添加顺序使用LinkMap,按照自然排序使用TreeMap,自定义TreeMap(Comparator c )</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"5-如果需要线程安全-且效率高的Map-应该怎么做\"><a href=\"#5-如果需要线程安全-且效率高的Map-应该怎么做\" class=\"headerlink\" title=\"5)如果需要线程安全,且效率高的Map,应该怎么做\"></a>5)如果需要线程安全,且效率高的Map,应该怎么做</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多线程环境下可以用concurrent包下的ConcurrentHashMap,</span><br><span class=\"line\">或者使用Collections.synchronizeMap().</span><br><span class=\"line\">ConcurrentHashMap虽然是线程安全的,但是他的仙侣比Hashtable要高的多</span><br><span class=\"line\"></span><br><span class=\"line\">为什么Collections.synchronizeMap()是线程安全的</span><br><span class=\"line\">因为使用Collections.synchronizeMap()后的map的方法都加锁了</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"6-HashMap的底层实现-源码\"><a href=\"#6-HashMap的底层实现-源码\" class=\"headerlink\" title=\"6)HashMap的底层实现,源码\"></a>6)HashMap的底层实现,源码</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">HashMap底层(数组+链表+红黑树 jdk8才有红黑树)</span><br><span class=\"line\">数组中每一项是一个链表 即数组和链表的结合体</span><br><span class=\"line\">jdk1.8中,链表的长度大于8,链表会转换成红黑树</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"7-解释一下hash碰撞-以及解决方法\"><a href=\"#7-解释一下hash碰撞-以及解决方法\" class=\"headerlink\" title=\"7)解释一下hash碰撞,以及解决方法\"></a>7)解释一下hash碰撞,以及解决方法</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash碰撞:不同的key计算得到的hash值相同,需要放到同个bucket中</span><br><span class=\"line\">解决办法: 链表法,开发地址法,再哈希法等</span><br><span class=\"line\">eg:链表法 hashmap使用的是链表法</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"8-hashMap底层是数组-链表-红黑树-为什么要用这几类结构呢\"><a href=\"#8-hashMap底层是数组-链表-红黑树-为什么要用这几类结构呢\" class=\"headerlink\" title=\"8)hashMap底层是数组+链表+红黑树,为什么要用这几类结构呢\"></a>8)hashMap底层是数组+链表+红黑树,为什么要用这几类结构呢</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组Node&lt;K,V&gt; value 根据对象的key和hash值进行在数组里面是那个节点</span><br><span class=\"line\">链表的作用是解决hash冲突,将hash值一样的对象存在一个链表放在hash值对应的曹位</span><br><span class=\"line\"></span><br><span class=\"line\">红黑树 jdk8使用红黑树来替代超过8个节点的链表 主要是提升查询性能</span><br><span class=\"line\">通过hash碰撞,让hashmap不断产生碰撞,那么相同的key的位置的链表就会不断增长,当对这个hashmap的相应</span><br><span class=\"line\">位置进行查询的时候,就会循环遍历这个超级大的链表,性能就会下降,所以改用红黑树</span><br><span class=\"line\"></span><br><span class=\"line\">为什么选择红黑树而不用其他树,比如二叉查找树,为啥不一值开始就用红黑树,而是到8的长度后变换</span><br><span class=\"line\">原因:二叉查找树主要是提升查找数据的速度,红黑树是平衡二叉树的一种,插入新数据后通过左旋右旋变色等操作来</span><br><span class=\"line\">保持平衡,解决单链表查询深度的问题</span><br><span class=\"line\"></span><br><span class=\"line\">数据量少的时候操作数据,遍历线性表比红黑树所消耗的资源少,且前期数据少 平衡二叉树保持平衡是需要消耗资源的</span><br><span class=\"line\">所以前期采用线性表等到一定数之后变换到红黑树</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"10-ConcurrentHashMap基础和原理-为什么性能比hashtable高-jdk1-7和jdk1-8的区别\"><a href=\"#10-ConcurrentHashMap基础和原理-为什么性能比hashtable高-jdk1-7和jdk1-8的区别\" class=\"headerlink\" title=\"10)ConcurrentHashMap基础和原理,为什么性能比hashtable高,jdk1.7和jdk1.8的区别\"></a>10)ConcurrentHashMap基础和原理,为什么性能比hashtable高,jdk1.7和jdk1.8的区别</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConcurrentHashMap:</span><br><span class=\"line\">线程安全的Map,hashtable的所有方法都采用Synchronize进行线程安全控制  高并发情况下效率降低</span><br><span class=\"line\">但是ConcurrentHashMap是采用分段锁的思想提高性能,锁粒度细化</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">jdk8之前ConcurrentHashMap采用分段锁技术,将数据分成一段段存储,每个数据段配置一把锁</span><br><span class=\"line\">即segment类,这个类继承ReentrantLock来保证线程安全</span><br><span class=\"line\">技术:Segment+HashEntry</span><br><span class=\"line\"></span><br><span class=\"line\">在jdk8的版本取消segment这个分段锁数据结构底层也是使用node数组+链表+红黑树,从而实现对每一段</span><br><span class=\"line\">数据进行加锁,也减少了并发冲突的概率,CAS(读)+Synchronize(写)</span><br><span class=\"line\">技术点: Node+CAS+Synchronized</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"11-ConcurrentHashMap的基础原理-put\"><a href=\"#11-ConcurrentHashMap的基础原理-put\" class=\"headerlink\" title=\"11)ConcurrentHashMap的基础原理:put\"></a>11)ConcurrentHashMap的基础原理:put</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//重hash,减少哈希碰撞</span><br><span class=\"line\">spread(key.hashCode());</span><br><span class=\"line\">//获取索引中下标为i的元素</span><br><span class=\"line\">tabAt(i);</span><br><span class=\"line\">//乐观锁,利用CAS操作获取table中索引为i的node元素</span><br><span class=\"line\">casTabAt(i);</span><br><span class=\"line\"></span><br><span class=\"line\">put核心流程:</span><br><span class=\"line\">1.key进行重哈希spread(key.hashCode());</span><br><span class=\"line\">2.对当前table进行无条件循环</span><br><span class=\"line\">3.如果没有初始化,则用initTable初始化(采用懒加载模式)</span><br><span class=\"line\">4.如果没有hash冲突,则直接用CAS插入新节点,成功后则直接判断是否需要扩容分,然后结束</span><br><span class=\"line\">5.(fh=f.hash)==MOVED 如果是这个状态则是扩容操作,先进行扩容</span><br><span class=\"line\">6.存在hash冲突,利用synchronize(f)就锁保证线程安全</span><br><span class=\"line\">7.如果是链表,则直接遍历插入,如果数量大于8,则需要转换成红黑树</span><br><span class=\"line\">8.如果是红黑树则按照红黑树规则插入</span><br><span class=\"line\">9.最后检查是否需要扩容addCount();</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"16-并发编程\"><a href=\"#16-并发编程\" class=\"headerlink\" title=\"16.并发编程\"></a>16.并发编程</h3><h4 id=\"1-线程-进程-协程的区别\"><a href=\"#1-线程-进程-协程的区别\" class=\"headerlink\" title=\"1)线程,进程,协程的区别\"></a>1)线程,进程,协程的区别</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">进程: </span><br><span class=\"line\">本质上是一个独立执行的程序,进程是操作系统进行资源分配和调度的基本概念,操作系统进行资源分配</span><br><span class=\"line\">和调度的独立单位</span><br><span class=\"line\"></span><br><span class=\"line\">线程: </span><br><span class=\"line\">是操作系统能够进行运算调度的最小单位,被包含在进程中,是进程中的实际运作单位,一个进程可以并发</span><br><span class=\"line\">多个线程,每条线程执行不同的任务,切换受系统控制</span><br><span class=\"line\"></span><br><span class=\"line\">协程:</span><br><span class=\"line\">又称微线程,是一种用户态的轻量级线程,协程不像线程和进程需要进行系统内核上的上下文切换,协程的</span><br><span class=\"line\">上下文切换是用户自己决定的,有自己的上下文,所以说是轻量级的线程,也称之为用户级别的线程就叫协程</span><br><span class=\"line\">一个线程可以多个协程,线程进程都是同步机制,而协程则是异步</span><br><span class=\"line\"></span><br><span class=\"line\">java的原生语法中并没有实现协程,目前py,lua,go支持</span><br><span class=\"line\"></span><br><span class=\"line\">关系:</span><br><span class=\"line\">  一个进程可以有多个线程,它允许计算机同时运行两个或多个程序,一个进程至少会有一个线程</span><br><span class=\"line\">  线程是进程的最小执行单位,cpu的调度切换的是进程和线程,进程和线程多了之后调度会消耗大量的额cpu</span><br><span class=\"line\">  线程是独立运行和独立调度的基本单位,cpu上真正运行的是线程,线程可以对应多个协程</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"2-协程对于对于多线程有什么优缺点\"><a href=\"#2-协程对于对于多线程有什么优缺点\" class=\"headerlink\" title=\"2)协程对于对于多线程有什么优缺点\"></a>2)协程对于对于多线程有什么优缺点</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">优点:</span><br><span class=\"line\">  非常快读的上下文切换 不用系统内核的上下文切花 减小开销</span><br><span class=\"line\">  单线程即可高并发 单核cpu可以支持上万的协程</span><br><span class=\"line\">  由于只有一个线程,也不存在同时写变量的冲突 在协程中控制共享资源不需要加锁</span><br><span class=\"line\"></span><br><span class=\"line\">缺点:</span><br><span class=\"line\">  协程无法利用多核资源 本质就是单个线程</span><br><span class=\"line\">  协程需要和进程配合才能运行在多cpu上</span><br><span class=\"line\">  目前java没成熟的第三方库 存在风险</span><br><span class=\"line\">  调式debug存在难度 不利于发现问题</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-并行和并发的区别\"><a href=\"#3-并行和并发的区别\" class=\"headerlink\" title=\"3)并行和并发的区别\"></a>3)并行和并发的区别</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并发:</span><br><span class=\"line\">  一台处理器上同时处理任务,这个同时实际上是交替处理多个任务 程序中可以同时拥有两个或者多个线程</span><br><span class=\"line\">  当有多个线程在操作时,如果系统中只有一个cpu 则它根本不可能真正同时进行一个以上的线程 它只能把cpu</span><br><span class=\"line\">  运行时间划分成若干个时间段 再将时间段分配给各个线程执行</span><br><span class=\"line\">  </span><br><span class=\"line\">并行:</span><br><span class=\"line\">  多个CPU同时处理多个任务,一个cpu执行一个进程时,另一个cpu可以执行另一个进程,两个进程互不抢占cpu资源</span><br><span class=\"line\">  可以同时进行</span><br><span class=\"line\">  </span><br><span class=\"line\">   并发指在一段时间内宏观上去处理多个任务 并行指同一时刻,多个任务确实真的同时运行</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"4-java实现多线程有哪几种放肆-不同-比较\"><a href=\"#4-java实现多线程有哪几种放肆-不同-比较\" class=\"headerlink\" title=\"4)java实现多线程有哪几种放肆,不同,比较\"></a>4)java实现多线程有哪几种放肆,不同,比较</h4><ul>\n<li><p>1、继承Thread类创建线程</p>\n</li>\n<li><p>2、实现Runnable接口创建线程</p>\n</li>\n<li><p>3、实现Callable接口通过FutureTask包装器来创建Thread线程<br>创建Callable接口的实现类 并实现call方法,结合FutureTask类包装Callable对象实现多线程<br>优点:有返回值,扩展性高<br>缺点:jdk1.5以后才支持 需要重写call方法 结合多个类比如FutureTask和Thread类<br>示例代码:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) {</span><br><span class=\"line\">      //Mytask mytask = new Mytask();</span><br><span class=\"line\">      FutureTask&lt;Object&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Object&gt;() {</span><br><span class=\"line\">          @Override</span><br><span class=\"line\">          public Object call() throws Exception {</span><br><span class=\"line\">              System.out.println(\"Callable实现多线程名称\"+Thread.currentThread().getName());</span><br><span class=\"line\">              return \"callThread\";</span><br><span class=\"line\">          }</span><br><span class=\"line\">      });</span><br><span class=\"line\"></span><br><span class=\"line\">      //FutureTask实现了Runnable接口可以放在Thread中启动执行</span><br><span class=\"line\">      Thread thread = new Thread(futureTask);</span><br><span class=\"line\">      thread.setName(\"demo\");</span><br><span class=\"line\">      thread.start();</span><br><span class=\"line\">      System.out.println(\"主线程名称\"+Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">      try {</span><br><span class=\"line\">          System.out.println(futureTask.get());</span><br><span class=\"line\">      } catch (InterruptedException e) {</span><br><span class=\"line\">          //阻塞等待中被中断抛出</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      } catch (ExecutionException e) {</span><br><span class=\"line\">          //阻塞等待中被中断,则抛出</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      }</span><br><span class=\"line\">  }</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>4、通过线程池创建<br>自定义Runnable接口 实现run方法 创建线程池 调用执行方法并传入对象<br>优点:安全高性能 复用线程<br>缺点:jdk 5后才支持 需要结合Runnable进行使用<br>示例代码:</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) {</span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) {</span><br><span class=\"line\">            executorService.execute(new ThreadPoolDemo());</span><br><span class=\"line\">        }</span><br><span class=\"line\">        System.out.println(\"主线程名称:\"+Thread.currentThread().getName());</span><br><span class=\"line\">        //关闭线程池</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n<p>一般常用的第二种和第四种<br>Runnable和线程池+Runnable 简单方便扩展 和高性能 (池化思想)</p>\n</li>\n</ul>\n<h4 id=\"5-线程状态有哪些\"><a href=\"#5-线程状态有哪些\" class=\"headerlink\" title=\"5)线程状态有哪些?\"></a>5)线程状态有哪些?</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdk的线程分6种,jvm有9种(一般说jdk)</span><br><span class=\"line\">常见的5种状态</span><br><span class=\"line\">* 创建(new): 生成线程对象 但是并没有调用该对象start(),new Thread()</span><br><span class=\"line\"></span><br><span class=\"line\">* 就绪(Runnable): 1)调用线程对象的start()方法 线程就进入就绪状态</span><br><span class=\"line\">                 2)线程运行后,从等待和睡眠中回来进入就绪状态</span><br><span class=\"line\">  但是此时线程调度还没有切换到当前线程,没有获取cpu使用权 只是有机会得到调度</span><br><span class=\"line\">  </span><br><span class=\"line\">* 运行(running): 程序就绪, cpu切换至当前线程进入运行状态</span><br><span class=\"line\"></span><br><span class=\"line\">* 阻塞(blocked): 1)等待阻塞: 需要等待其他线程做出一定动作(通知或中断),这种情况下cpu不会分配过来</span><br><span class=\"line\">需要被唤醒,也可能无限等待,wait()或者sleep(),join或者发出io请求 阻塞结束后线程重新进入就绪状态</span><br><span class=\"line\">                 2)同步阻塞: 线程在获取synchronized同步所失败,即被其他线程占用 就会进入同步阻塞</span><br><span class=\"line\">                 </span><br><span class=\"line\">* 死亡(terminal): 一个线程run方法执行结束 不能重新进入运行状态</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"6-线程的常见方法\"><a href=\"#6-线程的常见方法\" class=\"headerlink\" title=\"6)线程的常见方法\"></a>6)线程的常见方法</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread自带方法:</span><br><span class=\"line\">sleep(): 交出cpu的使用权,等待预计时间之后再恢复 不会释放锁 进入阻塞状态 睡眠结束变为就绪Runnable</span><br><span class=\"line\">yield(): 属于线程Thread的方法 暂停当前线程对象 去执行其他对象 让相同优先级的线程先执行</span><br><span class=\"line\">         不会让线程进入阻塞状态 直接变为就绪Runnable 只需要重新获得cpu使用权</span><br><span class=\"line\">join(): 在主线程上调用该方法会让主线程休眠 不会释放已经持有的对象锁</span><br><span class=\"line\">       让调用join方法的线程先执行完毕 再执行其他线程 类似于救护车</span><br><span class=\"line\"></span><br><span class=\"line\">Object顶级类带的方法:</span><br><span class=\"line\">wait(): 当前线程调用对象wait方法 会释放锁 进入线程的等待队列 需要依靠notify|notifyall唤醒</span><br><span class=\"line\">notify(): 唤醒在对象监视器上等待的单个线程 选择是任意的</span><br><span class=\"line\">notifyAll(): 唤醒在对象监视器上等待的全部线程</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"7-业务代码中的多线程-业务场景\"><a href=\"#7-业务代码中的多线程-业务场景\" class=\"headerlink\" title=\"7)业务代码中的多线程,业务场景\"></a>7)业务代码中的多线程,业务场景</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 异步任务:</span><br><span class=\"line\">  用户注册 记录日志 </span><br><span class=\"line\">  定时任务:定期备份日志 备份数据库</span><br><span class=\"line\">  分布式计算: Hadoop处理任务mapreduce master-wark单机单进程</span><br><span class=\"line\">  服务器编程: Socket网络编程 一个连接一个线程</span><br><span class=\"line\"></span><br><span class=\"line\">* 不是线程安全的数据结构</span><br><span class=\"line\">HashMap ArrayList LinkedList</span><br><span class=\"line\"></span><br><span class=\"line\">* java中可以有哪些方法来保证线程安全</span><br><span class=\"line\">加锁 比如synchronize/ReentrantLock</span><br><span class=\"line\">使用volatile声明变量 轻量级同步 不能保证原子性</span><br><span class=\"line\">使用线程安全类(并发容器,原子类,同步容器 CopyOnWriteArrayList/... Thread 本地私有变量等)</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"8-volatile关键字-与synchronize的区别\"><a href=\"#8-volatile关键字-与synchronize的区别\" class=\"headerlink\" title=\"8)volatile关键字?与synchronize的区别\"></a>8)volatile关键字?与synchronize的区别</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">扩展:</span><br><span class=\"line\">1、原子性</span><br><span class=\"line\">即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断  </span><br><span class=\"line\">要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</span><br><span class=\"line\"></span><br><span class=\"line\">2、可见性</span><br><span class=\"line\">可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volatile: 是轻量级的synchronize 保证了共享变量的可见性,被它修饰的变量</span><br><span class=\"line\">          如果值发生改变其他线程立刻可见,避免出现藏独线程</span><br><span class=\"line\">          保证可见性 但是不能保证原子性</span><br><span class=\"line\">          </span><br><span class=\"line\">synchronize: 保证可见性 也保证原子性</span><br><span class=\"line\"></span><br><span class=\"line\">使用场景:</span><br><span class=\"line\">1.不能修饰写入操作依赖当前值的变量 比如num++,num=num+1,不是原子操作</span><br><span class=\"line\">  肉眼看起来是但是jvm字节码层面不止一步</span><br><span class=\"line\"></span><br><span class=\"line\">2.由于禁止了指令重排所以jvm相关的优化没了效率会偏弱</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"9-为什么会出现脏读\"><a href=\"#9-为什么会出现脏读\" class=\"headerlink\" title=\"9)为什么会出现脏读?\"></a>9)为什么会出现脏读?</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java内存模型简称 JMM</span><br><span class=\"line\">JMM规定所以的变量存在主内存 每个线程有自己的工作内存  </span><br><span class=\"line\">线程对变量的操作都在工作内存中进行 不能直接对主内存进行操作</span><br><span class=\"line\"></span><br><span class=\"line\">使用volatile修饰变量 每次读取钱必须从主内存属性获取最新的值</span><br><span class=\"line\">每次写入需要立刻写到主内存中</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"10-什么是指令重排？\"><a href=\"#10-什么是指令重排？\" class=\"headerlink\" title=\"10)什么是指令重排？\"></a>10)什么是指令重排？</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">指令重排序分俩类: </span><br><span class=\"line\">编译器重排序和运行时重排序</span><br><span class=\"line\">JVm编译java代码或者CPU执行JVM字节码时,对现有指令进行重新排序,主要目的是优化运行效率(不改变程序结果的前提)</span><br><span class=\"line\"></span><br><span class=\"line\">虽然指令重排序可以提高执行效率但是多线程上可能会影响结果有什么解决办法?</span><br><span class=\"line\">解决办法:内存屏障</span><br><span class=\"line\">解释: 内存屏障是屏障指令 是cpu对屏障指令之前和之后的内存操作执行结果的一种约束</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"11-happens-before吗-能否简单解释下\"><a href=\"#11-happens-before吗-能否简单解释下\" class=\"headerlink\" title=\"11)happens-before吗,能否简单解释下?\"></a>11)happens-before吗,能否简单解释下?</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先行发生原则,volatile的内存可见性体现了该原则之一</span><br><span class=\"line\">八大原则:</span><br><span class=\"line\">1.程序次序规则</span><br><span class=\"line\">2.管理锁定规则</span><br><span class=\"line\">3.volatile变量规则</span><br><span class=\"line\">4.线程启动规则</span><br><span class=\"line\">5.线程中断规则</span><br><span class=\"line\">6.线程终止规则</span><br><span class=\"line\">7.对象终结规则</span><br><span class=\"line\">8.传递性</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"17并发编程进阶\"><a href=\"#17并发编程进阶\" class=\"headerlink\" title=\"17并发编程进阶\"></a>17并发编程进阶</h3><p>1)并发编程三要素</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.原子性: 要么全部执行 要么全部执行失败</span><br><span class=\"line\">private int num =0;</span><br><span class=\"line\">    ReentrantLock lock = new ReentrantLock();</span><br><span class=\"line\">    public void add(){</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try {</span><br><span class=\"line\">            num++;</span><br><span class=\"line\">        }finally {</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    //使用synchronized和上述是一个操作 这个是保证方法被锁住 上述是代码块被锁住</span><br><span class=\"line\">    public synchronized void put(){</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">不能存在上下文切换,线程会带来原子性的问题</span><br><span class=\"line\">解决办法是可以用synchronize或lock(比如ReetrantLock)来吧这个多操作变成原子性操作</span><br><span class=\"line\">但是volatile,前面有说道不能修饰有依赖值的情况</span><br><span class=\"line\">解决方法的核心思想:把一个方法或者代码块看做一个整体 保证是一个不可分割的整体</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2.有序性</span><br><span class=\"line\">解决方式:加锁禁止指令重排</span><br><span class=\"line\"></span><br><span class=\"line\">3.可见性</span><br><span class=\"line\">同样加锁synchronize或lock或者validate能够保证线程可见性</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"2进程间的调度算法\"><a href=\"#2进程间的调度算法\" class=\"headerlink\" title=\"2进程间的调度算法\"></a>2进程间的调度算法</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.先来先服务调度算法:</span><br><span class=\"line\">  按照作业/进制程到达的先后顺序</span><br><span class=\"line\">  排在长进程后的短进程的等待时间长 不利于短作业</span><br><span class=\"line\"></span><br><span class=\"line\">2.短作业优先调度算法</span><br><span class=\"line\">  短作业在实际情况中占有很大比例 对长作业不友好</span><br><span class=\"line\"></span><br><span class=\"line\">3.高响应比优先调度算法</span><br><span class=\"line\">  在每次调度时,先计算各个作业的优先权 </span><br><span class=\"line\">  优先权: 优先权= 响应比=(等待时间+要求服务时间)/要求服务时间</span><br><span class=\"line\">  需要计算优先权信息,增减了系统开销</span><br><span class=\"line\"></span><br><span class=\"line\">4.时间片轮调度算法</span><br><span class=\"line\">  轮流的为各个进程服务,让每个进程在一定时间间隔内都可以得到响应</span><br><span class=\"line\">  由于高频率的进程切换增加了系统开销,并且不区分任务的紧急程度</span><br><span class=\"line\">  </span><br><span class=\"line\">5.优先级调度算法</span><br><span class=\"line\">  根据任务的紧急程度进行调度 高优先级的先处理</span><br><span class=\"line\">  如果高优先级任务很多且持续产生 那么低优先级的可能很慢才被处理</span><br><span class=\"line\">  </span><br><span class=\"line\">  每种算法都有他的优缺点根据业务选择</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-线程间的调度算法-java是哪种\"><a href=\"#3-线程间的调度算法-java是哪种\" class=\"headerlink\" title=\"3)线程间的调度算法 java是哪种\"></a>3)线程间的调度算法 java是哪种</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程调度时指系统为线程分噢诶cpu使用权的过程,主要分为两种</span><br><span class=\"line\"></span><br><span class=\"line\">1.协同式线程调度(分时调度模式):</span><br><span class=\"line\">  线程执行时间自由由线程本身来控制 线程把自己的工作执行完之后 要主动通知系统切换倒另外一个线程上</span><br><span class=\"line\">  最大好处是实现简单 且切换操作对线程自己是可知的 没有线程同步问题</span><br><span class=\"line\">  坏处是线程执行时间不可控制 如果一个线程有问题 可能一直阻塞在那里</span><br><span class=\"line\"></span><br><span class=\"line\">2.抢占式线程调度: 每个贤臣由系统分配执行时间 线程的切换不由线程本身来决定</span><br><span class=\"line\">可以让出执行时间 但无法获取执行时间 线程执行时间系统可控 也不会有一个线程导致整个进程阻塞</span><br><span class=\"line\"></span><br><span class=\"line\">java是抢占式调度,优先让可运行池中优先级高的线程占用cpu </span><br><span class=\"line\">如果可运行池中的线程优先级相同 那就随机选择一个线程</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">wait() ,notify()看上去是线程本身控制其实不是,是随机在队列中获取而已</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"4-java中常用的锁\"><a href=\"#4-java中常用的锁\" class=\"headerlink\" title=\"4)java中常用的锁\"></a>4)java中常用的锁</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">悲观锁: (和乐观锁成对出现,乐观锁: 每次获取数据时都认为别人不会修改,更新的时候回去判断是否更新数据,通过版本</span><br><span class=\"line\">判断,数据修改就拒绝更新,比如CAS是乐观锁</span><br><span class=\"line\">)悲观锁:当线程去操作数据时,总认为背的线程会去修改数据所以每次它拿数据的时候都会上锁别的线程就会阻塞</span><br><span class=\"line\"></span><br><span class=\"line\">公平锁: 指多个线程按照申请锁的顺序来获取锁 简单来说如果一个线程组里 能保证每个线程都能拿到锁</span><br><span class=\"line\">        比如ReentrantLock,底层是同步队列FIFO:First Input First OUtput来实现的</span><br><span class=\"line\">非公平锁:获取锁的方式是随机获取的 保证不了每个线程都能拿到锁 也就存在有线程饿死拿不到锁的情况</span><br><span class=\"line\">小结: 非公平锁性能高于公平锁 能重复利用cpu时间</span><br><span class=\"line\"></span><br><span class=\"line\">可重入锁: 也叫递归锁 在外层使用锁以后内层仍然可以使用 并且不发生死锁</span><br><span class=\"line\">不可重入锁: 若当前线程执行某个方法以及获得了该锁 那么在方法中尝试再次获取锁时就会被阻塞</span><br><span class=\"line\">小结: 可重入锁能一定程度的避免死锁 synchronize ReentrantLock </span><br><span class=\"line\"></span><br><span class=\"line\">自旋锁: 一个线程在获取锁的时候 如果锁已经被其他线程获取 那么该线程循环等待 </span><br><span class=\"line\">然后不断的判断是否锁能被成功获取直到获取到锁才会退出循环 任何时刻最低只能有一个执行单元获得锁</span><br><span class=\"line\">小结: 不会发生线程状态的奇幻 一直处于用户态 减少了线程上下文的切换的消耗 缺点是循环会消耗cpu</span><br><span class=\"line\">常见的自旋锁: TicketLock CLHLock MSCLock</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"5-日常开发用过的锁\"><a href=\"#5-日常开发用过的锁\" class=\"headerlink\" title=\"5)日常开发用过的锁\"></a>5)日常开发用过的锁</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">共享锁: 也叫s锁/读锁 能查看但无法修改和删除数据的一种数据锁 加锁后其他用户可以并发读取查询数据但是不能修改</span><br><span class=\"line\">       增加,删除数据,该锁可被多个线程所持有 用于资源共享</span><br><span class=\"line\"></span><br><span class=\"line\">互斥锁: 也叫X锁/排他锁/写锁/独占锁/独享锁 该锁每一次只能被一个线程所持有 加锁后任何线程试图再次加锁都会被</span><br><span class=\"line\">       阻塞,直到当前线程解锁</span><br><span class=\"line\">       </span><br><span class=\"line\">死锁: 俩个或俩个以上的线程在执行过程中由于竞争资源或者由于彼此通信而造成的一种阻塞的现象若无外力作用</span><br><span class=\"line\">     将无法让程序继续进行</span><br><span class=\"line\"></span><br><span class=\"line\">jvm锁的升级:</span><br><span class=\"line\">synchronize-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</span><br><span class=\"line\">其他锁: 分段锁, 行锁,表锁</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"6-手写死锁\"><a href=\"#6-手写死锁\" class=\"headerlink\" title=\"6)手写死锁\"></a>6)手写死锁</h4><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","permalink":"https://azure0919.github.io/posts/6f4fed30/","excerpt":"","categories":[{"name":"study","slug":"study","permalink":"https://azure0919.github.io/categories/study/"}],"tags":[{"name":"basic-knowledge","slug":"basic-knowledge","permalink":"https://azure0919.github.io/tags/basic-knowledge/"}]},{"title":"BCrypt:Illegal base64 character 24","date":"2020-02-26T07:14:08.000Z","path":"/posts/dbdc2f2/","text":"关于Base64的加密解密 只是测试用,一般是不会用作密码加密的因为这个解密非常简单,代码如下: 123if(BCrypt.checkpw(password,user.getPassword())){ //这里省略匹配成功后的代码} 报错信息如下 1234java.lang.IllegalArgumentException: Illegal base64 character 24 at java.util.Base64$Decoder.decode0(Base64.java:714) ~[na:1.8.0_231] at java.util.Base64$Decoder.decode(Base64.java:526) ~[na:1.8.0_231] at java.util.Base64$Decoder.decode(Base64.java:549) ~[na:1.8.0_231] emmm,又没解决!!!但是我大概猜到是因为数据库的问题了正常情况密码经过加密再存储的但是现在是直接导入的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<p>关于Base64的加密解密</p>\n<p>只是测试用,一般是不会用作密码加密的因为这个解密非常简单,代码如下:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(BCrypt.checkpw(password,user.getPassword())){</span><br><span class=\"line\">    <span class=\"comment\">//这里省略匹配成功后的代码</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>报错信息如下</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: Illegal base64 character <span class=\"number\">24</span></span><br><span class=\"line\">\tat java.util.Base64$Decoder.decode0(Base64.java:<span class=\"number\">714</span>) ~[na:<span class=\"number\">1.8</span><span class=\"number\">.0_231</span>]</span><br><span class=\"line\">\tat java.util.Base64$Decoder.decode(Base64.java:<span class=\"number\">526</span>) ~[na:<span class=\"number\">1.8</span><span class=\"number\">.0_231</span>]</span><br><span class=\"line\">\tat java.util.Base64$Decoder.decode(Base64.java:<span class=\"number\">549</span>) ~[na:<span class=\"number\">1.8</span><span class=\"number\">.0_231</span>]</span><br></pre></td></tr></tbody></table></figure>\n\n<p>emmm,又没解决!!!但是我大概猜到是因为数据库的问题了<br>正常情况密码经过加密再存储的但是现在是直接导入的</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","permalink":"https://azure0919.github.io/posts/dbdc2f2/","excerpt":"","categories":[{"name":"bug","slug":"bug","permalink":"https://azure0919.github.io/categories/bug/"}],"tags":[{"name":"BCrypt","slug":"BCrypt","permalink":"https://azure0919.github.io/tags/BCrypt/"}]},{"title":"IDEA Plugins collections","date":"2020-02-24T11:44:28.000Z","path":"/posts/6de8b2c/","text":"IDEA这款代码工具相信很多人都在用,好的插件使编码更加舒适顺畅一些,下面为大家介绍几款本人常用的插件,如果大家有好用的欢迎推荐交流(由于现在评论模块尚未开通,只能点击左边eamil邮件沟通啦十分抱歉) 实力派插件,开点外挂 1231.Alibaba java Coding Guidelinges 实时检测功能会在开发过程中对当前文件进行检测，并以高亮的形式提示出来，同时也可以支持Quick Fix，该功能默认开启，可以通过配置关闭。 更多详细内容可参考:https://github.com/alibaba/p3c 1232.Codota 最好的代码实例,是继IntelliJ后，代码补全方面锦上添花的智能AI代码补全插件，使用Codota将拥有全球数百万个顶级代码示例。 官方下载渠道:https://plugins.jetbrains.com/plugin/7638-codota 1234563.Free Mybatis plugin 是一款增强idea对mybatis支持的插件,生成mapper xml文件快速从代码跳转到mapper及从mapper返回代码,mybatis自动补全及语法错误提示,集成mybatis generator gui界面 官方下载:https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin 更多详细内容参考:https://github.com/wuzhizhan/free-idea-mybatis (不知道为何作者迁移到gitee然后项目404,此链接还可打开三个月前有维护记录) 1234.JRebel for Intellij 热部署插件,可实时编译解决在项目运行状态run/debug 状态下任意修改java文件并动态反馈到运行的项目中,省去很多重启时间,已不再免费提供注册但是可以使用破解版,大家可以网上搜索看看 官方下载:https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij 1235.Lombok 目前这个插件相信大家最熟悉不过了,自动插入编辑器和构建工具,不用再手动编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等 官方下载:https://plugins.jetbrains.com/plugin/6317-lombok 1236.Translation 翻译插件,中英翻译, 可以当词典用,详细资料参考 官方文档:https://github.com/YiiGuxing/TranslationPlugin 1237.Markdown support 提供了在IDE中编辑Markdown文件并在实时预览中查看渲染的HTML的功能 官方下载:https://plugins.jetbrains.com/plugin/7793-markdown 1238.RestfulToolkit 一套 RESTful 服务开发辅助工具集,有效解决在无接口文档时，双方的联调工作,并且在idea上可直接使用再也不用频繁切换测试工具窗口了,此工具适合做接口测试，以及敏捷开发时使用，真证前后端分离式开发 官方下载:https://plugins.jetbrains.com/plugin/10292-restfultoolkit 接下来是一些花里胡哨的插件可以给我们的平淡的代码生活带来一点色彩 1231.Crep Console 可以设置不同级别log的字体颜色和背景色,同时它还可以将打开任意文件并进行日志高亮 官方下载:https://plugins.jetbrains.com/plugin/7125-grep-console 1232.Nyan progress bar 普通的人进度条都太普通，我的精致要装扮到每一个细节，包括进度条！可以显示成彩虹跳跃的样子哦 官方下载:https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar 1233.Background Image Plus 嗯嗯程序员有女朋友的可以把女朋友设置为背景墙,嗯对着女朋友编程哈哈如果没有的话当我没说,设置成你的信仰吧 官方下载:https://plugins.jetbrains.com/plugin/8502-background-image-plus enmmm暂时就这些等下次再遇到好的插件再补齐给大家吧! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<p>IDEA这款代码工具相信很多人都在用,好的插件使编码更加舒适顺畅一些,下面为大家介绍几款本人常用的插件,如果大家有好用的欢迎推荐交流(由于现在评论模块尚未开通,只能点击左边eamil邮件沟通啦十分抱歉)</p>\n<p>实力派插件,开点外挂</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.Alibaba java Coding Guidelinges</span><br><span class=\"line\">    实时检测功能会在开发过程中对当前文件进行检测，并以高亮的形式提示出来，同时也可以支持Quick Fix，该功能默认开启，可以通过配置关闭。</span><br><span class=\"line\">    更多详细内容可参考:https:<span class=\"comment\">//github.com/alibaba/p3c</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>.Codota</span><br><span class=\"line\">    最好的代码实例,是继IntelliJ后，代码补全方面锦上添花的智能AI代码补全插件，使用Codota将拥有全球数百万个顶级代码示例。</span><br><span class=\"line\">    官方下载渠道:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/7638-codota</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>.Free Mybatis plugin</span><br><span class=\"line\">    是一款增强idea对mybatis支持的插件,生成mapper xml文件快速从代码跳转到mapper及从mapper返回代码,</span><br><span class=\"line\">mybatis自动补全及语法错误提示,集成mybatis generator gui界面</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/8321-free-mybatis-plugin</span></span><br><span class=\"line\">    更多详细内容参考:https:<span class=\"comment\">//github.com/wuzhizhan/free-idea-mybatis</span></span><br><span class=\"line\">    (不知道为何作者迁移到gitee然后项目<span class=\"number\">404</span>,此链接还可打开三个月前有维护记录)</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span>.JRebel <span class=\"keyword\">for</span> Intellij</span><br><span class=\"line\">    热部署插件,可实时编译解决在项目运行状态run/debug 状态下任意修改java文件并动态反馈到运行的项目中,省去很多重启时间,已不再免费提供注册但是可以使用破解版,大家可以网上搜索看看</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>.Lombok</span><br><span class=\"line\">    目前这个插件相信大家最熟悉不过了,自动插入编辑器和构建工具,不用再手动编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/6317-lombok</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6.Translation</span><br><span class=\"line\">  翻译插件,中英翻译, 可以当词典用,详细资料参考</span><br><span class=\"line\">  官方文档:https://github.com/YiiGuxing/TranslationPlugin</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>.Markdown support</span><br><span class=\"line\">    提供了在IDE中编辑Markdown文件并在实时预览中查看渲染的HTML的功能</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/7793-markdown</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span>.RestfulToolkit</span><br><span class=\"line\">    一套 RESTful 服务开发辅助工具集,有效解决在无接口文档时，双方的联调工作,并且在idea上可直接使用再也不用频繁切换测试工具窗口了,此工具适合做接口测试，以及敏捷开发时使用，真证前后端分离式开发</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/10292-restfultoolkit</span></span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<p>接下来是一些花里胡哨的插件可以给我们的平淡的代码生活带来一点色彩</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.Crep Console</span><br><span class=\"line\">    可以设置不同级别log的字体颜色和背景色,同时它还可以将打开任意文件并进行日志高亮</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/7125-grep-console</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>.Nyan progress bar</span><br><span class=\"line\">    普通的人进度条都太普通，我的精致要装扮到每一个细节，包括进度条！可以显示成彩虹跳跃的样子哦</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/8575-nyan-progress-bar</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>.Background Image Plus</span><br><span class=\"line\">    嗯嗯程序员有女朋友的可以把女朋友设置为背景墙,嗯对着女朋友编程哈哈如果没有的话当我没说,设置成你的信仰吧</span><br><span class=\"line\">    官方下载:https:<span class=\"comment\">//plugins.jetbrains.com/plugin/8502-background-image-plus</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>enmmm暂时就这些等下次再遇到好的插件再补齐给大家吧!</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","permalink":"https://azure0919.github.io/posts/6de8b2c/","excerpt":"","categories":[{"name":"plug","slug":"plug","permalink":"https://azure0919.github.io/categories/plug/"}],"tags":[{"name":"plug-in","slug":"plug-in","permalink":"https://azure0919.github.io/tags/plug-in/"}]},{"title":"spring-cloud-gateway-yml","date":"2020-02-22T12:31:56.000Z","path":"/posts/80819933/","text":"spring-cloud-gateway的配置是这样的 1234567891011121314151617gateway: routes: - id: goods_route #唯一表示符号 #uri: http://localhost:18081 #用户请求需要路由到该服务[指定要路由的服务] uri: lb://goods #使用loadBalanceClient 实现负载均衡后面是微服务的名称[主要用于集群环境单体可直接写地址] predicates: #路由断言[规则] #- Host=cloud.sx.nine** #用户请求域名配置规则,所有以cloud.sx.nine的请求都将被路由至http://localhost:18081微服务 #- Path=/api/brand/** #根据请求路径过滤,所有以/brand开始的请求都路由至http://localhost:18081微服务 - Path=/** filters: - StripPrefix=1 #将请求路径中的第一个路径去掉,请求路径以/区分,一个/代表一个路径 #- PrefixPath=/band #用户所有请求添加/brand前缀并且将该请求路由到http://localhost:18081微服务 - name: RequestRateLimiter args: key-resolver: \"#{@ipKeyResolver}\" redis-rate-limiter.replenishRate: 1 redis-rate-limiter.burstCapacity: 4 报错是这样的 12345678Caused by: org.yaml.snakeyaml.parser.ParserException: while parsing a block collection in 'reader', line 20, column 13: - Path=/api/brand/** #根据请求路径过滤,所 ... ^expected &lt;block end&gt;, but found '&lt;block mapping start&gt;' in 'reader', line 21, column 14: filters: ^ 哎头疼 yml配置文件对格式要求太严格了解决方案: StripPrefix与name对齐 其他的跟随缩进就好了 12345678filters: - StripPrefix=1 #将请求路径中的第一个路径去掉,请求路径以/区分,一个/代表一个路径 #- PrefixPath=/band #用户所有请求添加/brand前缀并且将该请求路由到http://localhost:18081微服务 - name: RequestRateLimiter args: key-resolver: \"#{@ipKeyResolver}\" redis-rate-limiter.replenishRate: 1 redis-rate-limiter.burstCapacity: 1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<p>spring-cloud-gateway的配置是这样的</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gateway:</span><br><span class=\"line\">      routes:</span><br><span class=\"line\">        - id: goods_route #唯一表示符号</span><br><span class=\"line\">          #uri: http://localhost:18081 #用户请求需要路由到该服务[指定要路由的服务]</span><br><span class=\"line\">          uri: lb:<span class=\"comment\">//goods #使用loadBalanceClient 实现负载均衡后面是微服务的名称[主要用于集群环境单体可直接写地址]</span></span><br><span class=\"line\">          predicates: #路由断言[规则]</span><br><span class=\"line\">            #- Host=cloud.sx.nine** #用户请求域名配置规则,所有以cloud.sx.nine的请求都将被路由至http://localhost:18081微服务</span><br><span class=\"line\">            #- Path=/api/brand/** #根据请求路径过滤,所有以/brand开始的请求都路由至http://localhost:18081微服务</span><br><span class=\"line\">            - Path=<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">          filters:</span></span><br><span class=\"line\"><span class=\"comment\">              - StripPrefix=1 #将请求路径中的第一个路径去掉,请求路径以/区分,一个/代表一个路径</span></span><br><span class=\"line\"><span class=\"comment\">              #- PrefixPath=/band #用户所有请求添加/brand前缀并且将该请求路由到http://localhost:18081微服务</span></span><br><span class=\"line\"><span class=\"comment\">          - name: RequestRateLimiter</span></span><br><span class=\"line\"><span class=\"comment\">            args:</span></span><br><span class=\"line\"><span class=\"comment\">              key-resolver: \"#{<span class=\"doctag\">@ipKeyResolver</span>}\"</span></span><br><span class=\"line\"><span class=\"comment\">              redis-rate-limiter.replenishRate: 1</span></span><br><span class=\"line\"><span class=\"comment\">              redis-rate-limiter.burstCapacity: 4</span></span><br></pre></td></tr></tbody></table></figure>\n<p>报错是这样的</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: org.yaml.snakeyaml.parser.ParserException: <span class=\"keyword\">while</span> parsing a block collection</span><br><span class=\"line\"> in <span class=\"string\">'reader'</span>, line <span class=\"number\">20</span>, column <span class=\"number\">13</span>:</span><br><span class=\"line\">                - Path=/api/brand<span class=\"comment\">/** #根据请求路径过滤,所 ... </span></span><br><span class=\"line\"><span class=\"comment\">                ^</span></span><br><span class=\"line\"><span class=\"comment\">expected &lt;block end&gt;, but found '&lt;block mapping start&gt;'</span></span><br><span class=\"line\"><span class=\"comment\"> in 'reader', line 21, column 14:</span></span><br><span class=\"line\"><span class=\"comment\">                 filters:</span></span><br><span class=\"line\"><span class=\"comment\">                 ^</span></span><br></pre></td></tr></tbody></table></figure>\n<p>哎头疼 yml配置文件对格式要求太严格了<br>解决方案:   </p>\n<p>StripPrefix与name对齐 其他的跟随缩进就好了</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filters:</span><br><span class=\"line\">           - StripPrefix=1 #将请求路径中的第一个路径去掉,请求路径以/区分,一个/代表一个路径</span><br><span class=\"line\">              #- PrefixPath=/band #用户所有请求添加/brand前缀并且将该请求路由到http://localhost:18081微服务</span><br><span class=\"line\">           - name: RequestRateLimiter</span><br><span class=\"line\">             args:</span><br><span class=\"line\">              key-resolver: <span class=\"string\">\"#{@ipKeyResolver}\"</span></span><br><span class=\"line\">              redis-rate-limiter.replenishRate: <span class=\"number\">1</span></span><br><span class=\"line\">              redis-rate-limiter.burstCapacity: <span class=\"number\">1</span></span><br></pre></td></tr></tbody></table></figure><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","permalink":"https://azure0919.github.io/posts/80819933/","excerpt":"","categories":[{"name":"bug","slug":"bug","permalink":"https://azure0919.github.io/categories/bug/"}],"tags":[{"name":"yml","slug":"yml","permalink":"https://azure0919.github.io/tags/yml/"}]},{"title":"nginx openresty content_by_lua_file 404","date":"2020-02-19T07:39:21.000Z","path":"/posts/51429/","text":"配置好lua脚本如下错误: 123 nginx openresty content_by_lua_file 404错误:2020/02/10 19:18:59 [error] 21231#0: *63 failed to load external Lua file \"/home/l/lua/content_lua.lua\":cannot open /home/l/lua/content_lua.lua: Permission denied, client: [ip], server: localhost, request: \"POST /lua_server HTTP/1.1\", host: \"[ip]+[port]\" nginx配置文件里添加 1user root root; 即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<p>配置好lua脚本如下错误:  </p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">nginx openresty content_by_lua_file 404错误:2020/02/10 19:18:59 [error] 21231#0: *63 failed to load external Lua file \"/home/l/lua/content_lua.lua\":</span><br><span class=\"line\">cannot open /home/l/lua/content_lua.lua: Permission denied, client: [ip], server: localhost, request: <span class=\"string\">\"POST /lua_server HTTP/1.1\"</span>, host: <span class=\"string\">\"[ip]+[port]\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>nginx配置文件里添加 </p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user root root;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>即可</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","permalink":"https://azure0919.github.io/posts/51429/","excerpt":"","categories":[{"name":"bug","slug":"bug","permalink":"https://azure0919.github.io/categories/bug/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://azure0919.github.io/tags/nginx/"}]},{"title":"blog introduce","date":"2020-02-16T06:50:35.000Z","path":"/posts/24267/","text":"关于博客 Welcome to my blog ! I would appreciate your guidance . 欢迎同行技术交流 不对的地方还请多多赐教 12345678910111213141516171819202122232425262728@Author: NineEr@Date: 2020/2/16 18:53@Description:关于我 \"这世上\" \"有人住高楼 有人在深沟\" \"有人光万丈 有人一身绣\" \"世人千万种 浮云莫去求\" \"斯人若彩虹 遇上方知有\"我是一个标准的天蝎座女孩,性子冷淡,骨子倔强,上进心事业心都很强,尊敬每一个努力上进的人.梦想注定是孤独的旅程,路上少不了质疑和嘲笑,但那又怎样,勇往直前最终到达彼岸的是你不是他们.对于心中有目标的你们,也包括我自己,也许一路上会碰到许多人,乱花渐入迷人眼,随时都可能转移注意力.但是我希望我们可以坚持下来,当然也会有好的建议,多多采纳虚心学习,前辈们走过你走的弯路.有人说:\"优秀的人注定是孤独的\" 所以大概走到最后的内心都很强大吧.可是我们也会遇到一个如彩虹般绚丽的人陪你走过这孤独的一生的啊,怕什么呢,勇敢往前走吧!最后一定要感谢一路陪你走来的所有人,不管好的坏的都是你的经历.在你的平淡人生中留下不可复刻的记忆! \"像我这样优秀的人 本该灿烂过一生 怎么二十多年到头来 还在人海里浮沉\" \"像我这样聪明的人 早就告别了单纯 怎么还是用了一段情 去换一身伤痕\" \"像我这样迷茫的人 像我这样寻找的人 像我这样碌碌无为的人 你还见过多少人\" \"像我这样庸俗的人 从不喜欢装深沉 怎么偶尔听到老歌时 忽然也晃了神\" \"像我这样懦弱的人 凡事都要留几分 怎么曾经也会为了谁 想过奋不顾身\" \"像我这样迷茫的人 像我这样寻找的人 像我这样碌碌无为的人 你还见过多少人\" \"像我这样孤单的人 像我这样傻的人 像我这样不甘平凡的人 世界上有多少人\" 毛不易这首歌的歌词,听到心里去了,最怕不甘平庸却还迟迟不愿行动.有人见尘埃,有人见星辰,祝你早日长成你想要的模样,祝你人间值得! 博客搭建参考:https://blog.csdn.net/weixin_39879178/article/details/80319392 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<blockquote>\n<p>关于博客</p>\n<blockquote>\n<p>Welcome to my blog ! I would appreciate your guidance .</p>\n</blockquote>\n</blockquote>\n<p>欢迎同行技术交流 不对的地方还请多多赐教</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Author</span>: NineEr</span><br><span class=\"line\"><span class=\"meta\">@Date</span>: <span class=\"number\">2020</span>/<span class=\"number\">2</span>/<span class=\"number\">16</span> <span class=\"number\">18</span>:<span class=\"number\">53</span></span><br><span class=\"line\"><span class=\"meta\">@Description</span>:关于我</span><br><span class=\"line\">    <span class=\"string\">\"这世上\"</span></span><br><span class=\"line\">    <span class=\"string\">\"有人住高楼 有人在深沟\"</span></span><br><span class=\"line\">    <span class=\"string\">\"有人光万丈 有人一身绣\"</span></span><br><span class=\"line\">    <span class=\"string\">\"世人千万种 浮云莫去求\"</span></span><br><span class=\"line\">    <span class=\"string\">\"斯人若彩虹 遇上方知有\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">我是一个标准的天蝎座女孩,性子冷淡,骨子倔强,上进心事业心都很强,尊敬每一个努力上进的人.</span><br><span class=\"line\">梦想注定是孤独的旅程,路上少不了质疑和嘲笑,但那又怎样,勇往直前最终到达彼岸的是你不是他们.</span><br><span class=\"line\">对于心中有目标的你们,也包括我自己,也许一路上会碰到许多人,乱花渐入迷人眼,随时都可能转移注意力.</span><br><span class=\"line\">但是我希望我们可以坚持下来,当然也会有好的建议,多多采纳虚心学习,前辈们走过你走的弯路.</span><br><span class=\"line\">有人说:<span class=\"string\">\"优秀的人注定是孤独的\"</span> 所以大概走到最后的内心都很强大吧.</span><br><span class=\"line\">可是我们也会遇到一个如彩虹般绚丽的人陪你走过这孤独的一生的啊,怕什么呢,勇敢往前走吧!</span><br><span class=\"line\">最后一定要感谢一路陪你走来的所有人,不管好的坏的都是你的经历.</span><br><span class=\"line\">在你的平淡人生中留下不可复刻的记忆!</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"string\">\"像我这样优秀的人 本该灿烂过一生 怎么二十多年到头来 还在人海里浮沉\"</span></span><br><span class=\"line\">  <span class=\"string\">\"像我这样聪明的人 早就告别了单纯 怎么还是用了一段情 去换一身伤痕\"</span></span><br><span class=\"line\">  <span class=\"string\">\"像我这样迷茫的人 像我这样寻找的人 像我这样碌碌无为的人 你还见过多少人\"</span></span><br><span class=\"line\">  <span class=\"string\">\"像我这样庸俗的人 从不喜欢装深沉 怎么偶尔听到老歌时 忽然也晃了神\"</span></span><br><span class=\"line\">  <span class=\"string\">\"像我这样懦弱的人 凡事都要留几分 怎么曾经也会为了谁 想过奋不顾身\"</span></span><br><span class=\"line\">  <span class=\"string\">\"像我这样迷茫的人 像我这样寻找的人 像我这样碌碌无为的人 你还见过多少人\"</span></span><br><span class=\"line\">  <span class=\"string\">\"像我这样孤单的人 像我这样傻的人 像我这样不甘平凡的人 世界上有多少人\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">毛不易这首歌的歌词,听到心里去了,最怕不甘平庸却还迟迟不愿行动.</span><br><span class=\"line\">有人见尘埃,有人见星辰,祝你早日长成你想要的模样,祝你人间值得!</span><br></pre></td></tr></tbody></table></figure>\n\n<p>博客搭建参考:<br><a href=\"https://blog.csdn.net/weixin_39879178/article/details/80319392\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_39879178/article/details/80319392</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","permalink":"https://azure0919.github.io/posts/24267/","excerpt":"","categories":[{"name":"blog","slug":"blog","permalink":"https://azure0919.github.io/categories/blog/"}],"tags":[{"name":"introduce","slug":"introduce","permalink":"https://azure0919.github.io/tags/introduce/"}]}]